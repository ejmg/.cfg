#+TITLE: Emacs configuration file
#+AUTHOR: spook
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* TODO
  - [ ] choose consistent format to package/PL setup
    - probably means difference between use-package'ing everything and making
      config blocks with more explicit annotations :(. I don't think
      use-package lends itself to literate programming as well, but it arguably
      leads to better package management and configuration overall.

* my-init
  configurations for my emacs. these configs are opinionated and by no
  guarantee "good." that said, i decided to return to vanilla emacs because it
  ensures i can debug issues and problems when they occur, something i lost in
  the midst of spacemac‚Äôs complexity. ergo, the return of my =.emacs= file.

  heavily inspired by [[https://github.com/larstvei/dot-emacs][Lar's]] and [[https://writequit.org/org/][Lee's]] dot-emacs files. I have learned a lot
  about what and what not to do from them.

** overview
*** philosophy
    the main of philosophy of this config is as follows, in order of
    importance:

    1. readability
       - without readability all is lost in an emacs config. everything will
         inevitably soon crumble after losing the ability to easily understand
         what is happening in the configuration.

    2. usability
       - it should work, damn it. nothing weird, and err towards simplicity
         over complexity

    3. modularity
       - avoid global configurations where uncalled for, e.g. less =(global-<MODE>)=

       - configuration functions are good, let‚Äôs use more of them!

*** how this works
    unlike Lar's configuration, my =init.el= will always be called. i like the
    idea of =init.el= always remaining untouched and pure.

    in =init.el=, i set my package repositories and then bootstrap
    =use-package= and =org=, these are the two pillars of my config and i
    want to guarantee they are working and up to date.

    from there, the init file loads this file (=my-init.org=), extracts all
    code blocks by "tangling" it, and produces the =.el= equivalent used by
    emacs.

**** use-package notes
***** =:init= vs =:config=

      - =:init= is executed upon the eval of a =(use-package ...)= declaration
        containing them, i.e. immediately when *this* file is evaluated by
        emacs, *always*.
        - not affected by whether the package is lazy loaded or not.

      - =:config= is executed *when* and only *if* the given package in a
        use-package declaration is evaluated. This is because of the lazy
        nature of package configurations.

      - Thus, you will typically want to use =:config= for settings specific
        the mode being loaded, e.g. =(setq some-mode-color ‚Äôred)=

*** TODO Decide whether I will byte compile my emacs config
    we want our changes in any =.org= config file to be reflected back into our actual =.el= files. The
    hook below achieves this by re-compiling the byte file of any config =.org= file edited.

    #+BEGIN_SRC emacs-lisp :tangle no
    (defun tangle-init ()
      "If the current buffer is 'config.org' the code-blocks are
    tangled, and the tangled file is compiled."
      (when (equal (buffer-file-name)
                   (expand-file-name (concat user-emacs-directory "config.org")))
        ;; Avoid running hooks when tangling.
        (let ((prog-mode-hook nil))
          (org-babel-tangle)
          (byte-compile-file (concat user-emacs-directory "config.el")))))

    (add-hook 'after-save-hook 'tangle-init)
    #+END_SRC

**** =use-package=
     always use =use-package= for loading up packages due to its lazy nature. this means emacs doesn't
     load something until it actually needs it, saving us a lot of time and some RAM by cutting boot
     times and pre-loading things when we might never use them.

** the basics
*** packages

    the spice of emacs begins with packages:

    #+BEGIN_SRC emacs-lisp
      (let* ((package--builtins nil)
             (packages
              '(
                ;; utilities
                ivy swiper counsel fill-column-indicator volatile-highlights
                golden-ratio undo-tree ace-window paredit projectile counsel-projectile diminish rainbow-delimiters
                smartparens ggtags expand-region ag neotree keychain-environment workgroups2 multiple-cursors
                dimmer pdf-tools smooth-scrolling exec-path-from-shell unfill xterm-color
                pandoc-mode lorem-ipsum quelpa-use-package sx alarm-clock symon
                ;;bookmarks+ dired+ no longer on melpa, need to config from emacs wiki or their mirror on github

                ;; keybindings
                general which-key


                ;; auto-complete
                company flycheck flycheck-tip hippie-exp yasnippet auto-yasnippet flycheck-irony company-c-headers
                elisp-slime-nav company-math company-auctex company-anaconda company-tern
                slime-company company-ycmd flycheck-rust enh-ruby-mode company-web
                company-ghci flycheck-haskell company-statistics yasnippet-snippets 


                ;; lsp stuff
                lsp-mode lsp-ui company-lsp dap-mode lsp-treemacs lsp-ivy

                ;; git
                magit diff-hl

                ;; markdown
                markdown-mode toml-mode yaml-mode

                ;; c/cpp
                clang-format cmake-mode

                ;; rust
                cargo racer rust-mode

                ;; lisp
                slime racket-mode

                ;; clojure
                cider cider-eval-sexp-fu clj-refactor clojure-mode clojure-snippets clojure-mode-extra-font-locking

                ;; haskell
                haskell-mode haskell-snippets hindent hlint-refactor

                ;; python
                anaconda-mode pyenv-mode hy-mode pytest py-yapf ;; python-pytest

                ;; TODO: actually set these up
                js-doc js2-mode js2-refactor rjsx-mode json-mode json-snatcher web-beautify coffee-mode vue-mode
                tide nodejs-repl

                ;; TODO: actually set these up to be used.
                ;; webprogramming
                haml-mode sass-mode scss-mode slim-mode web-mode less-css-mode pug-mode emmet-mode

                ;; TODO: SETUP
                ;; ruby
                bundler chruby rbenv rspec-mode rubocop ruby-tools rvm rake

                ;; elm
                elm-mode

                ;; tex
                auctex auctex-latexmk typo cdlatex

                ;; org
                org-bullets org-pomodoro org-download htmlize org-journal secretaria org-download toc-org
                ;; not compiling correctly, investigate later
                ;; org-plus-contrib

                ;; themes
                challenger-deep-theme exotica-theme seti-theme gandalf-theme cyberpunk-theme dark-mint-theme dracula-theme material-theme
                kaolin-themes minimal-theme smart-mode-line-powerline-theme

                ;; other
                writeroom-mode minimap gnuplot csv-mode mips-mode smart-mode-line fireplace anki-editor emojify wolfram
                define-word

                ;; google
                google-this google-translate

                )))
        (let ((packages (remove-if 'package-installed-p packages)))
          (when packages
            ;; Install uninstalled packages
            (package-refresh-contents)
            (mapc 'package-install packages))))
    #+END_SRC
**** local packages
     setup the directory used for custom packages, i.e. stuff that isn't typically up on melpa but i
     might find on github, the emacs wiki, or i might write myself
     #+BEGIN_SRC emacs-lisp
       (let ((default-directory (concat (expand-file-name (concat user-emacs-directory "custom/")))))
         (normal-top-level-add-subdirs-to-load-path))
     #+END_SRC
**** quelpa/quelpa-use-package
     These allow me to install emacs packages from non-traditional sources, i.e. git repos and
     whatnot. It's a lot more powerful than that, but tbh i'll probably only ever use it for git
     repos.
     #+BEGIN_SRC emacs-lisp
       (use-package quelpa
         :ensure t)
         ;; this lets me use quelpa as if its use-package
       (use-package quelpa-use-package
         :ensure t)
     #+END_SRC
*** general settings

    things that don't seem to go anywhere because of their generality or edge-case nature:
**** FONTS

     I have given up on ligatures for now in GUI emacs. It's just too
     painful/work to maintain, and even then I never got it working at a level
     of consistency that made it satisfactory. For now, I just default to Fira
     Code but don't do anything to enable ligatures.

     #+BEGIN_SRC emacs-lisp
       ;; experiment to fix tooltip font errors

       ;; emacs typically comes built with GTK support, and will default
       ;; to using the tooltips of GTK. However, this doesn't play nicely
       ;; when it comes to any kind of customizations because GTK has control
       ;; over the tooltips, not emacs. Swerve.
       (setq x-gtk-use-system-tooltips nil)

       ;; (set-frame-font "Fira Code") ;;; set default font
       ;; (setq default-frame-alist '((font . "Fira Code-10"))) ;; set it for the daemon itself


       (setq default-frame-alist '((font . "-CTDB-Fira Code-normal-normal-normal-*-14-*-*-*-m-0-iso10646-1")))
       ;; set it for the daemon itself
     #+END_SRC

**** system defaults

    #+BEGIN_SRC emacs-lisp
      ;; need this for things like pyenv to work with emacs daemon.
      ;; this is a recent development and apparently has something to do with the fact
      ;; i am using the daemon as a systemd unit. that shouldn't be a problem. to checkout later.
      (exec-path-from-shell-initialize)

      ;; no splash screen, sorry Stallman
      (setq inhibit-splash-screen t)

      ;; disables annoying noise, "bell", triggered with actions such as hitting
      ;; the end of a buffer.
      (setq visible-bell t)

      ;; ensure things like gpg and ssh agent are handled automatically
      (keychain-refresh-environment)


      ;; don't use the tool or scroll bar, thx
      (tool-bar-mode -1)
      (scroll-bar-mode -1)

      ;; sometimes I do like the menu bar, but not currently
      (menu-bar-mode -1)

      ;; scrolling speed is bad, make it nicer
      ;; NOTE: It appears smooth scrolling has a very perverse effect on
      ;; erc mode by hogging up the cpu by a significant %. Disabling for now.
      ;; (smooth-scrolling-mode 1)
      (setq mouse-wheel-progressive-speed nil)

      ;; UTF-8 is our friend in a world of shitty programming standards
      (set-language-environment "UTF-8")
      (prefer-coding-system 'utf-8)
      (set-default-coding-systems 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      ;;(setq default-buffer-file-coding-system 'utf-8)

      ;; speaking of text, unify emacs clipboard with linux
      (setq x-select-enable-clipboard t)

      ;; global hl line mode
      (global-hl-line-mode t)

      ;; can't get flycheck mode to enable itself otherwise
      (global-flycheck-mode)

      ;; make our mode line prettier
      (use-package smart-mode-line
        :config
        (setq sml/no-confirm-load-theme t
              ;; As it stands, I actually like the dark theme
              ;; in conjunction with minimal-light more than sml's light theme
              sml/theme 'dark)
        (sml/setup))


      ;; make sure it attempts utf-8 first when pasting text into emacs
      (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

      ;; always tell me the column and row of where i am please, i am already lost
      ;; enough as is.
      (line-number-mode 1)
      (column-number-mode 1)

      ;; do you seriously think i'm good at typing
      (setq read-file-name-completion-ignore-case t)

      ;; life is too short for fully authenticating bad decisions
      (defalias 'yes-or-no-p 'y-or-n-p)

      ;; fix bad escape sequence weirdness
      (setq system-uses-terminfo nil)

      ;; stronk encryption good
      ;;------------------------
      ;; TODO figure out how to make this compatible with erc-tls because
      ;; 4096 encryption makes any connection impossible because freenode uses
      ;; sub-4096 encryption
      ;; (setq gnutls-min-prime-bits 4096)

      ;; don't let me be moronic and kill emacs w/o warning. GUI only.
      (when (window-system)
        (setq confirm-kill-emacs 'yes-or-no-p))

      ;; move through lines based on visual appearance rather than literal. Very
      ;; useful for long, single lines.
      (setq line-move-visual t)

      ;; differentiate buffers with identical names
      (use-package uniquify
        :config
        (setq uniquify-buffer-name-style 'post-forward-angle-brackets))

      ;; use newer files rather than old compiled files, .elc
      (setq load-prefer-newer t)

      ;; if emacs crashes w/o warning, we want a valid list of recent files, don't we?
      (run-at-time nil (* 5 60) 'recentf-save-list)

      ;; finally, set emacs to display the path directory in the menu bar
      ;; displays current working directory at all times in emacs
      (setq frame-title-format
            (list (format "%s %%S: %%j " (system-name))
                  '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))
    #+END_SRC
**** garbage collection & read process throughput
     emacs' default gc threshold is set an extraordinarily small value, like 80KB, which is great
     in terms of performance relative to other text editors sans Vim; however, since we use [[lsp
     mode]], to get performance on par with other IDE's like VSCode, we need to increase it a fair
     amount. This is per the [[https://emacs-lsp.github.io/lsp-mode/page/performance/][LSP recommendations themselves]]:
     #+BEGIN_SRC emacs-lisp
     (setq gc-cons-threshold 150000000) ;; 150mb
     #+end_src

     for a similar reason, we need to increase the amount of data that emacs can read from a single
     process. The default is at 4KB when we need somewhere between 800KB-3MB:
     #+BEGIN_SRC emacs-lisp
     (setq read-process-output-max (* 1024 1024)) ;; 1mb
     #+end_src
**** truncate line fringe
     by default, truncate lines will show a little arrow pointing right when a line is longer than
     the visual line of the current frame. when i use fill-column-indicater mode (fci), which i do
     for basically all programming buffers, this results in the entire right fringe being covered in
     arrows whenever the frame is of a smaller width than the fill column i've set for that given
     language. this tweak here simply removes the fringe indicater for line truncation because,
     afaik, i've never needed emacs to warn me of a line truncation, at least when using the GUI
     version.
     #+begin_src emacs-lisp
       (setq-default fringe-indicator-alist (assq-delete-all 'truncation fringe-indicator-alist))
     #+end_src
     the above tweak was taken from [[https://www.reddit.com/r/emacs/comments/2t16il/is_there_a_way_to_remove_the_truncated_lines/cnurpo4?utm_source=share&utm_medium=web2x][sergeinosov]]
**** delete selection mode
     if you C-a while in a text box on a browser like firefox and then type anything, whether the
     character "f" or hit the backspace key, the whole selection of text is deleted. emacs, by
     default, doesn't do this. instead, when a region is marked, it just appends the text and
     deactivates the selection. in newish versions of emacs, though, you can enable the behavior you
     typically expect via =delect-section-mode=. that's what we're doing here.

     #+begin_src emacs-lisp
       (delete-selection-mode 1)
     #+end_src

**** buffer, symon display
     Basically gives me system stats in my buffer when I'm not using it. It's nice, but was causing
     some weird issues at some point so I disabled tangling it for now.
     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package symon
         :ensure t
         :config
         (progn  
           (setq symon-refresh-rate 5 ;; Refresh less by 1 second
                 symon-history-size 35 ;; keep history shorter by 15 observations to more quickly see patterns as they occur.
                 ))
         (symon-mode)
         )
     #+END_SRC
**** frame-parameters
     *now that i don't use emacs built with gtk, i'm disabling these for now and will remove/update
     as necessary after trial run*

     So tooltip is messy and has given me a lot of headaches over the months. Here are some tweaks
     that make it work better after hours of agonizing procrastination and self-inflicted pain.

     #+BEGIN_SRC emacs-lisp :tangle no
       (setq tooltip-frame-parameters
             '((name . "tooltip")
               (internal-border-width . 2)
               (border-width . 0)
               (no-special-glyphs . t)
               (right-divider-width . 0)
               (bottom-divider-width . 0)
               (menu-bar-lines . 0)
               (tool-bar-lines . 0)
               (right-fringe . 0)
               (inhibit-double-buffering . t)
               (undecorated . t)
               ;; (frame-inhibit-implied-resize t)
               ;; (internal-border-width . 300)
               ;; (line-spacing . 0)
               ;; (line-height . 1.5)
               ;; lsp-ui tooltip has these settings but they don't seem to help
               ;;
               ;; (unsplittable . t)
               ;; (width . 400)
               ;; (height . 200)
               ;; (min-height . 0)
               ;; (min-width . 0)
               ))

     #+END_SRC

     i don't think this has anything to do with it, but it's more of a basic precaution:
     #+BEGIN_SRC emacs-lisp :tangle no
       (setq x-max-tooltip-size '(260 . 140))
     #+END_SRC
**** limit buffer name size in modeline
     Sometimes I have very long file names (think textbook pdfs) and it makes
     seeing anything else on my mode line impossible. So let's reduce what can
     be shown:
     #+BEGIN_SRC emacs-lisp
       (setq-default mode-line-buffer-identification (list -40 (propertized-buffer-identification "%12b")))
     #+END_SRC
**** which-key and general.el
     Which-key is a very nice minor-mode that essentially gives a preview of
     all possible key completions available based on the current key stroke,
     saving you the hassle of having to memorize *every* key binding, and thus
     protecting you from going full emacs hermit.


     general defines "leader" keys/keystrokes, which allows you to setup mappings
     predicated off of a set of leader keys. For example, I set "C-c m" to be
     the leader keystroke for all of my magit commands I typically use.

     key bindings are left to the actual key binding section

     #+BEGIN_SRC emacs-lisp
       (use-package general
         :ensure t)

       (use-package which-key
         :diminish ""
         :init
         (which-key-mode)
         :config
         ;; already by default, but explicitly setting for popup to be in a bottom
         ;; frame.
         (which-key-setup-side-window-bottom)
         ;; ensures popup cannot take up more than .15 of emacs window
         (setq which-key-side-window-max-height .10))
     #+END_SRC
**** fill-column, spaces, tabs, and unfilling paragraphs
     I like my line wrapping, generally speaking, at around 80 characters. I change this for
     different languages, but when in markup/markdown langs like org-mode I still prefer my lines
     wrapping at around 80 chars.

     unfill helps with making a set of lines that I select be formed into a proper paragraph that
     wraps at the current fill-column value.
     #+BEGIN_SRC emacs-lisp
       (setq-default fill-column 79)
       (use-package unfill)
     #+END_SRC


     I generally don't use tabs and what them to be treated with a width of 2 when they do appear.
     #+begin_src emacs-lisp
       (setq-default indent-tabs-mode nil)
       (setq-default default-tab-width 2)     
     #+end_src
**** theme, styling, and transparency
     #+BEGIN_SRC emacs-lisp
       ;; Set transparency of emacs
       (defun transparency (value)
         "Sets the transparency of the frame window. 0=transparent/100=opaque"
         (interactive "nTransparency Value 0 - 100 opaque:")
         (set-frame-parameter (selected-frame) 'alpha value))

       ;; i have one them i play with that isn't on melpa
       (add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")

       (use-package colorless-themes
         :quelpa (colorless-themes :fetcher github :repo "lthms/colorless-themes.el"))

       (use-package kaolin-themes)
       (use-package minimal-theme)
       ;; for dark: seti, kaolin-aurora;
       ;; for light: gandalf, kaolin-valley-light
       ;; when i feel like a hacker: cyberpunk or dark-mint
       ;; 'challenger-deep
       (load-theme 'minimal-light t)


       ;; required to have custom-theme-set-faces work again: https://emacs.stackexchange.com/a/52804
       (setq custom--inhibit-theme-enable nil)

       (custom-theme-set-faces
        'minimal-light
        '(region ((t (:foreground "gainsboro" :background "dim grey"))))
        '(show-paren-match ((t (:background "gray30" :foreground "white" :weight extrabold))))
        '(org-block-begin-line ((t (:foreground "gray70" :background "gray98"))))
        '(org-block-end-line ((t (:foreground "gray70" :background "gray98"))))
        '(tooltip ((t (:background "gray90" :height 0.95 :family "Fira Code"))))
        '(italic ((t (:font "Fira Sans" :slant italic))))
        '(lsp-ui-sideline-code-action ((t (:foreground "DarkRed"))))
        '(lsp-ui-sideline-current-symbol ((t (:foreground "DarkBlue"))))
        '(lsp-ui-sideline-symbol ((t (:foreground "Black"))))
        '(lsp-ui-doc-background ((t (:background "gray92"))))
        '(aw-leading-char-face ((t (:background "white smoke" :foreground "red" :box (:line-width 1 :color "black") :height 2.5))))
        '(table-cell ((t (:background "LightSteelBlue" :foreground "black"))))
        '(fringe ((t (:background "gray100"))))
        '(lsp-ui-doc-border ((t (:border "black"))))
        )
       ;; (with-eval-after-load "minimal-theme"
       ;;   (setq lsp-ui-doc-border "black")
       ;;   )

       ;; (custom-theme-set-faces
       ;;  'gandalf
       ;;  '(lsp-ui-sideline-code-action ((t (:foreground "DarkRed"))))
       ;;  '(lsp-ui-sideline-current-symbol ((t (:foreground "MediumBlue")))))

       ;; pretty symbols
       (setq-default prettify-symbols-alist '(("lambda" . ?Œª)
                                              (".\\" . ?Œª)
                                              ("->" . ?‚ü∂)
                                              ("=/=" . ?‚â†)
                                              ("===" . ?‚â°)
                                              ("!=" . ?‚â†)
                                              ("<=" . ?‚â§)
                                              (">=" . ?‚â•)
                                              ("alpha" . ?Œ±)
                                              ("beta" . ?Œ≤)
                                              ("Gamma" . ?Œì)
                                              ("gamma" . ?Œ≥)
                                              ("Delta" . ?Œî)
                                              ("delta" . ?Œ¥)
                                              ("epsilon" . ?Œµ)
                                              ("theta" . ?Œ∏)
                                              ("mu" . ?Œº)
                                              ("Xi" . ?Œû)
                                              ("xi" . ?Œæ)
                                              ("Pi" . ?Œ†)
                                              ("pi" . ?œÄ)
                                              ("rho" . ?œÅ)
                                              ("Sigma" . ?Œ£)
                                              ("sigma" . ?œÉ)
                                              ("tau" . ?œÑ)
                                              ("Phi" . ?Œ¶)
                                              ("phi" . ?œÜ)
                                              ("psi" . ?œà)
                                              ("Omega" . ?Œ©)
                                              ("omega" . ?œâ)
                                              ;; ("x" . x)
                                              ))
       ;; dims the buffers that are not active
       (use-package dimmer
         :config
         (setq dimmer-fraction 0.4)
         (dimmer-mode))
     #+END_SRC
**** window and file history

     #+BEGIN_SRC emacs-lisp
       ;; C-c LEFT to undo window change, which i need often
       (use-package winner
         :init (winner-mode 1))

       ;; TODO figure out if i want to figure out wg.
       (use-package workgroups2
         :config
         (setq wg-default-session-file "~/.emacs.d/.wg"))
       ;; (workgroups-mode 1)
       ;; (setq wg-prefix-key (kbd "C-c w"))
       ;; (setq wg-switch-on-load nil)
       ;;(wg-file "~/.workgroups")



       ;; re-opens file at last place edited
       (use-package saveplace
         :defer t
         :init
         (setq-default save-place t)
         (setq save-place-file (expand-file-name ".places" user-emacs-directory)))

       ;; enables recent-files to be re-opened
       (recentf-mode 1)
       (setq recentf-max-menu-items 50)

       ;; do not need spam in recents list
       (setq recentf-exclude '("/auto-install/" ".recentf" "/repos/" "/elpa/"
                               "\\.mime-example" "\\.ido.last" "COMMIT_EDITMSG"
                               ".gz"
                               "~$" "/tmp/" "/ssh:" "/sudo:" "/scp:"))
       (global-set-key "\C-x\ \C-r" 'recentf-open-files)

       ;;(desktop-save-mode 1)
     #+END_SRC
**** projectile

     #+BEGIN_SRC emacs-lisp
       (use-package projectile
         :diminish ""
         :init
         (projectile-mode))

       (use-package counsel-projectile
         :hook projectile-mode)


       ;; This defun assumes I am always switching python projects and that I
       ;; name my pyenvs after specific projects. It causes a lot of unecessary
       ;; error messages in my buffer for reasons listed above. Tweak or get rid of.


       ;; (defun projectile-pyenv-mode-set ()
       ;;   "Set pyenv version matching project name."
       ;;   (let ((project (projectile-project-name)))
       ;;     (if (member project (pyenv-mode-versions))
       ;;         (pyenv-mode-set project)
       ;;       (pyenv-mode-unset))))

       ;; (add-hook 'projectile-after-switch-project-hook 'projectile-pyenv-mode-set)

     #+END_SRC
**** Ivy, Swiper
     #+BEGIN_SRC emacs-lisp
       (ivy-mode 1)
       (diminish 'ivy-mode)
       (setq ivy-use-virtual-buffers t)
       (setq enable-recursive-minibuffers t)
       (global-set-key "\C-s" 'swiper)
       (global-set-key (kbd "C-c C-r") 'ivy-resume)
       (global-set-key (kbd "<f6>") 'ivy-resume)
       (global-set-key (kbd "M-x") 'counsel-M-x)
       (global-set-key (kbd "C-x C-f") 'counsel-find-file)
       (global-set-key (kbd "<f1> f") 'counsel-describe-function)
       (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
       (global-set-key (kbd "<f1> l") 'counsel-find-library)
       (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
       (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
       (global-set-key (kbd "C-c g") 'counsel-git)
       (global-set-key (kbd "C-c j") 'counsel-git-grep)
       (global-set-key (kbd "C-c k") 'counsel-ag)
       (global-set-key (kbd "C-x l") 'counsel-locate)
       ;; (global-set-key (kbd "C-S-o") 'counsel-rhythmbox) ;; don't use rhythm box lol
       (define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history)
     #+END_SRC
**** dired
     #+BEGIN_SRC emacs-lisp
       (defun my/dired-mode-hook ()
         (toggle-truncate-lines 1))

       (use-package dired
         :bind ("C-x C-j" . dired-jump)
         :config
         (progn
           (use-package dired-x
             :init (setq-default dired-omit-files-p t)
             :config
             (add-to-list 'dired-omit-extensions ".DS_Store"))
           (customize-set-variable 'diredp-hide-details-initially-flag nil)
           ;; (use-package dired+) no longer available via melpa
           (use-package dired-aux
             :init (use-package dired-async))
           (put 'dired-find-alternate-file 'disabled nil)
           (setq ls-lisp-dirs-first t
                 dired-recursive-copies 'always
                 dired-recursive-deletes 'always
                 dired-dwim-target t
                 ;; -F marks links with @
                 dired-ls-F-marks-symlinks t
                 delete-by-moving-to-trash t
                 ;; i typically want to see hidden files
                 dired-omit-mode nil
                 ;; Auto refresh dired
                 global-auto-revert-non-file-buffers t
                 wdired-allow-to-change-permissions t))
         (add-hook 'dired-mode-hook #'my/dired-mode-hook))
     #+END_SRC
**** spelling

     #+BEGIN_SRC emacs-lisp
       (use-package flyspell
         :diminish ""
         :init
         (add-hook 'text-mode-hook 'turn-on-flyspell))
         ;; flyspell currently messes with company mode so we will suffer for now.
         ;; (add-hook 'prog-mode-hook 'flyspell-prog-mode)

         ;; make ispell fast and make it only look at 3 char+ words
       (setq ispell-extra-args
             (list "--sug-mode=fast" ;; ultra|fast|normal|bad-spellers
                   "--lang=en_US"
                   "--ignore=3"))
     #+END_SRC

     really nice package for finding definitions without leaving emacs. by same
     author behind ivy, swiper. Thanks abo-abo!

     #+BEGIN_SRC emacs-lisp
       (use-package define-word)
     #+END_SRC
**** multiple cursors
     this is a dope package that makes multi-line editing a breeze. to be
     mastered later but for future ref, =mc/edit-lines=,
     =mc/edit-ends-of-lines=, =mc/edit-beginnings-of-lines= are commands i'll
     probably use the most.
     #+BEGIN_SRC emacs-lisp
       (use-package multiple-cursors)
     #+END_SRC
**** whitespace
     #+BEGIN_SRC emacs-lisp
       ;; whitespace checker starts at 80
       (setq whitespace-line-column 80)

       ;; what whitespace looks for
       (setq whitespace-style '(tabs newline space-mark
                          tab-mark newline-mark
                          face lines-tail))

       ;; special visual market up for non-whitespace
       (setq whitespace-display-mappings
             ;; all numbers are Unicode codepoint in decimal. e.g. (insert-char 182 1)
             ;; 32 SPACE, 183 MIDDLE DOT
             '((space-mark nil)
               ;; 10 LINE FEED
               ;;(newline-mark 10 [172 10])
               (newline-mark nil)
               ;; 9 TAB, MIDDLE DOT
               (tab-mark 9 [183 9] [92 9])))

       ;; disabled for modes that it doesn't make sense
       (setq whitespace-global-modes '(not org-mode
                                          eshell-mode
                                          shell-mode
                                          web-mode
                                          log4j-mode
                                          "Web"
                                          dired-mode
                                          emacs-lisp-mode
                                          clojure-mode
                                          lisp-mode))
     #+END_SRC
**** backup files

     #+BEGIN_SRC emacs-lisp
       (setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
         backup-by-copying t    ; Don't delink hardlinks
         version-control t      ; Use version numbers on backups
         delete-old-versions t  ; Automatically delete excess backups
         kept-new-versions 20   ; how many of the newest versions to keep
         kept-old-versions 5    ; and how many of the old
         )
     #+END_SRC
**** kill/copy line
     #+BEGIN_SRC emacs-lisp
       (defun slick-cut (beg end)
         (interactive
          (if mark-active
              (list (region-beginning) (region-end))
            (list (line-beginning-position) (line-beginning-position 2)))))

       (advice-add 'kill-region :before #'slick-cut)

       (defun slick-copy (beg end)
         (interactive
          (if mark-active
              (list (region-beginning) (region-end))
            (message "Copied line")
            (list (line-beginning-position) (line-beginning-position 2)))))

       (advice-add 'kill-ring-save :before #'slick-copy)
     #+END_SRC
**** PDFs, Documents
     - basic settings for how i want my pdf's handled. I use pdf-view
       (pdf-tools), which gives way better resolution, performance, and also
       even annotation logic!

       This makes sure it sets up as expected. It should run once and then
       never be an issue again.
       #+BEGIN_SRC emacs-lisp
         (use-package pdf-tools)

         ;; throws error about not being a thing
         ;; (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode))
         (pdf-loader-install)
       #+END_SRC
***** Searching PDFs.
      So searching a PDF with =swiper=, which is my default search fn bound to
      =C-s=, leads to a lot of bad behavior, i.e. it literally searches the PDF
      binary. Not only does this not do what anyone would normally expect... it
      can severely slow down emacs on larger PDFs (learned that one the hard
      way, lol).

      Luckily, there is a keybinding that fixes that:
      #+BEGIN_SRC emacs-lisp
        (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
        (define-key pdf-view-mode-map (kbd "j") 'pdf-view-next-line-or-next-page)
        (define-key pdf-view-mode-map (kbd "k") 'pdf-view-previous-line-or-previous-page)
      #+END_SRC
***** Doc-View resolution
      For documents that cannot use pdftools, e.g. djvu or ppt files, the
      resolution can be really crappy sometimes. This makes it better:

      #+BEGIN_SRC emacs-lisp
        (setq doc-view-resolution 200)
      #+END_SRC
**** compilation buffer
     By default, the compilation buffer created when running a command via =M-x
     compile= doesn't account for xterm colors and other escape code related
     things. =xterm-color= handles this effectively via the following:

     #+BEGIN_SRC emacs-lisp
       (use-package xterm-color)

       (setq compilation-environment '("TERM=xterm-256color"))

       (add-hook 'compilation-start-hook
                 (lambda (proc)
                   ;; We need to differentiate between compilation-mode buffers
                   ;; and running as part of comint (which at this point we assume
                   ;; has been configured separately for xterm-color)
                   (when (eq (process-filter proc) 'compilation-filter)
                     ;; This is a process associated with a compilation-mode buffer.
                     ;; We may call `xterm-color-filter' before its own filter function.
                     (set-process-filter
                      proc
                      (lambda (proc string)
                        (funcall 'compilation-filter proc
                                 (xterm-color-filter string)))))))
     #+END_SRC
** completion

   this section concerns primarily two modes: =lsp= and =company=. both have to do with autocomplete but
   at different levels and overlap in the nature of their functionality but do so as complements.

   i also like using =yasnippet= for autocompletion of boilerplate-like snippets of code,
   i.e. function declaration, a testing module in rust, etc.

   finally, there are some other small sections in here to do with things like undo or syntax checking/linting.

*** =lsp=
   
    #+BEGIN_SRC emacs-lisp
      (use-package lsp-mode
        :ensure t
        :hook ((rust-mode . lsp)
               (web-mode . lsp)
               (elm-mode . lsp)
               (lsp-mode . lsp-enable-which-key-integration))
        :commands lsp)     

      (use-package company-lsp :commands company-lsp
        :config
        ;; caching always good. less lag/compilation.
        (setq company-lsp-cache-candidates 'auto
              ;; otherwise completion candidates come with arg params
              ;; which is often more annoying than not, imho.
              lsp-enable-snippet nil))
    #+END_SRC

    lsp-ui helps give pretty popups with API/library information for whatever completion candidate I
    may be looking at. I disable childrame because it felt laggy/stole focus iirc and am tentatively
    trying out the ability to see my docs and peek at declarations.
    #+begin_src emacs-lisp
      (use-package lsp-ui :commands lsp-ui-mode
        :ensure t
        :config
        (progn
          (setq lsp-ui-peek-enable t
                lsp-ui-doc-use-childframe nil
                lsp-ui-doc-enable t
                )))
    #+end_src

    lsp ivy allows me to use lsp to search symbols in an lsp workspace:
    #+begin_src emacs-lisp
      (use-package lsp-ivy :commands lsp-ivy-workspace-symbol)
    #+end_src

    this lets me see a list of my errors using treemacs:
    #+begin_src emacs-lisp
      (use-package lsp-treemacs :commands lsp-treemacs-errors-list)
    #+end_src

*** =company=
    
    company is the driver for most auto-complete functionality. it provides a common interface for
    different backends to integrate with in order to offer completion candidates across different
    languages, modes.

    the settings i provide below do a few things, in order:
    - associate which key to trigger completion on
    - trigger company on all buffers considered a programming buffer
    - set the delay for company to look for candidates at 0.1 seconds
    - require a minimum of 2 characters before looking up candidates
      + for dabbrev in particular, which looks across all buffers for a best-guess attempt, require
        3 characters
      + don't allow dabbrev to spend more than 0.05 seconds looking
      + make dabbrev case sensitive
    - sort the results by occurrence

    #+begin_src emacs-lisp
      (use-package company
        :defer t
        :diminish ""
        :bind ("C-." . company-complete)
        :init (add-hook 'prog-mode-hook 'company-mode)
        :config
        (progn
          (setq company-idle-delay 0.1
                company-minimum-prefix-length 2
                company-selection-wrap-around t
                company-dabbrev-minimum-length 3
                company-dabbrev-time-limit 0.05
                company-dabbrev-downcase nil
                company-transformers '(company-sort-by-occurrence))
          (bind-keys :map company-active-map
                     ("C-n" . company-select-next)
                     ("C-p" . company-select-previous)
                     ("C-d" . company-show-doc-buffer)
                     ("C-;" . company-complete))))

      (use-package company-web)

      ;; haskell
      (eval-after-load "company"
        '(add-to-list 'company-backends 'company-ghci))

      ;; python
      (eval-after-load "company"
        '(add-to-list 'company-backends '(company-anaconda :with company-capf)))

      ;; rust
      (add-to-list 'company-backends '(company-lsp :with company-yasnippet))

      ;; elm
      (add-to-list 'company-backends 'elm-company)
    #+end_src

    company-statistics tries to help put more relevant candidates at the top of your company results
    after some usage. the configuration is straightforward per [[https://github.com/company-mode/company-statistics][readme]]:
    #+begin_src emacs-lisp
      (use-package company-statistics
        :ensure t)
      (add-hook 'after-init-hook 'company-statistics-mode)
    #+end_src

*** yasnippet
    #+begin_src emacs-lisp
      (use-package yasnippet :diminish ""
        :config
        (diminish 'yas-minor-mode))
      (yas-global-mode 1)
    #+end_src

    to get yasnippet to work with company mode, let's sure it is enabled for all modes that are
    valid:
    #+begin_src emacs-lisp
      (defun mars/company-backend-with-yas (backends)
            "Add :with company-yasnippet to company BACKENDS.
      Taken from https://github.com/syl20bnr/spacemacs/pull/179."
            (if (and (listp backends) (memq 'company-yasnippet backends))
                backends
              (append (if (consp backends)
                          backends
                        (list backends))
                      '(:with company-yasnippet))))

          ;; add yasnippet to all backends
          (setq company-backends
                (mapcar #'mars/company-backend-with-yas company-backends))
    #+end_src

*** ignore buffers with bad completion candidates
    I use dabbrev mode as a completion candidate with company mode. This means
    it will look at other buffers for strings to complete from when it can't
    find anything from an intelligent completion engine/source. However, if
    you are reading a PDF (or tex log file, etc), you can get literal escape
    sequences as completion candidates. It also adds a good amount of lag due
    to the sheer number being looked at as potential completion candidates.

    This should stop it... I think.

    #+BEGIN_SRC emacs-lisp
      (setq company-files-exclusions '(".pdf" ".fbd_latexmk" ".aux" ".log" ".bbl"
                                      ".bcf" ".gz" ".blg" ".fls" ".doc" ".docx" ".ppt" ".pptx" ".odt"))
    #+END_SRC

    This function sets =company-dabbrev-ignore-buffers= to anything matching a
    .pdf file.

    #+BEGIN_SRC emacs-lisp
      (defun company-dabbrev-ignore-pdfs (buffer)
        "ignore all pdf buffers"
        (string-match-p "\\.pdf\\|\\.doc\\|\\.docx\\|\\.ppt\\|\\.pptx\\|\\.odt"
                     (buffer-name buffer)))
      (setq company-dabbrev-ignore-buffers 'company-dabbrev-ignore-pdfs)
    #+END_SRC

*** expand region
    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :bind ("M-/" . er/expand-region))
    #+END_SRC
*** flycheck
    #+BEGIN_SRC emacs-lisp
      (defun my-flycheck-customize ()
        (interactive)
        (global-set-key (kbd "C-c C-n") 'flycheck-tip-cycle)
        (global-set-key (kbd "C-c C-p") 'flycheck-tip-cycle-reverse))

      (use-package flycheck
        :defer t
        :bind (("M-g M-n" . flycheck-next-error)
               ("M-g M-p" . flycheck-previous-error)
               ("M-g M-=" . flycheck-list-errors))
        :diminish ""
        :config
        (use-package flycheck-tip
          :config (add-hook 'flycheck-mode-hook 'my-flycheck-customize)))
    #+END_SRC
*** undo tree
    #+BEGIN_SRC emacs-lisp

      (use-package undo-tree
        :init (global-undo-tree-mode t)
        :defer t
        :diminish ""
        :config
        (progn
          (define-key undo-tree-map (kbd "C-x u") 'undo-tree-visualize)
          (define-key undo-tree-map (kbd "C-/") 'undo-tree-undo)
          (define-key undo-tree-map (kbd "C-M-/") 'undo-tree-redo)))
    #+END_SRC
*** smartparens
    apparently smart parents totally has configurations for diff langs, such as rust, that you can
    enable automatically:
    #+BEGIN_SRC emacs-lisp
      (require 'smartparens-config)
    #+END_SRC
** special modes
**** git/magit
***** diff-hl
      package by same person maintaining/behind company-mode, so you know it‚Äôs
      that good ish üëåüèº
      #+BEGIN_SRC emacs-lisp
        (use-package diff-hl
          :init
          (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
          (add-hook 'prog-mode-hook 'diff-hl-margin-mode))
      #+END_SRC
**** TODO bookmarks
     i want to start using these, but am not sure where to get started with them.

     =bookmark+= is only hosted on the emacswiki and its github mirror ran by Jonas Bernoulli, so I
     gotta clone it first and require it. I should use quelpa or something to better handle this.
     #+BEGIN_SRC emacs-lisp

     #+END_SRC
**** TODO spotify
     as of now spotify w/o async doesn't work too hot, so ontop of having to install it locally
     under custom, i have to use the async branch until it updates.

     i would use quelpa, but idk how to specify which branch to use and can't seem to find immediate
     docs for that. For when that gets fixed, *TODO*:
     - [ ] re-enable quelpa + use-package
     - [ ] make shortcut to easily restart spotifyd when it hiccups
       - could just make hook to run eshell command with my alias
     #+BEGIN_SRC emacs-lisp
       (require 'spotify)

       (eval-after-load "spotify"
         '(setq spotify-remote-mode-map (make-sparse-keymap)))

       (load "~/.emacs.d/.spotify-auth")
       (setq spotify-transport 'connect)
       (setq spotify-api-search-limit 20)
       (setq spotify-mode-line-truncate-length 10)
       ;; How often it basically runs a blocking
       ;; query for all of my ****ing emacs daemon
       ;; just to update the song title in modeline.
       ;; Default is once a second. Try that on a low
       ;; bandwidth connection and see how productive
       ;; you can be.
       (setq spotify-mode-line-refresh-interval 60)
       (setq spotify-mode-line-format "[%p: %a - %t|%r%s]")

       ;; (use-package spotify
       ;;   ;; For now, need async branch and it appears that this isn't being picked
       ;;   ;; up by quelpa??
       ;;   :quelpa (spotify
       ;;            :fetcher github
       ;;            :repo "danielfm/spotify.el")
       ;;   :config
       ;;   ;; my config secrets
       ;;   (load "~/.emacs.d/.spotify-auth")
       ;;   ;; ability to use/control other devices running my spotify via emacs ü§ì
       ;;   (setq spotify-transport 'connect)
       ;;   ;; bit plus of this mode is i can run the spotifyd on my linux
       ;;   ;; machine and use <10kb of memory and virtually ~0% cpu, so
       ;;   ;; clogging my emacs instance with huge api searches seems
       ;;   ;; assinine lol
       ;;   (setq spotify-api-search-limit 20)
       ;;   (setq spotify-mode-line-truncate-length 20))
     #+END_SRC
**** TODO org

     one day i'll have proper documentation for this entire sub-heading.

     generic settings/my initialization hook for org-mode.

     #+BEGIN_SRC emacs-lisp
     (defun generic-org-minor-modes ()
         (interactive)
         (org-bullets-mode 1)
         ;; I don't really use cdlatex mode that much anymore, so i'm
         ;; disabling it for now. if i realize i miss it/incidentally used it before,
         ;; i'll reenable it later. otherwise i'll delete this line entirely soon.
         ;; (org-cdlatex-mode 1)

         ;; emojify mode results in top level, single *, headings to get replaced with literal solid black square
         ;; emojy somehow and fucks with things in a very special way. until i can unfuck that, i'm disabling it.
         ;; (emojify-mode 1)

         ;; org-mode uses visual line mode, which makes sense for text editing.
         ;; however, it means that if you ever look at an org-mode file without
         ;; line-wrapping behavior, you can have huge long lines of text that is hard
         ;; to read. i generally don't like that, so i enable auto-fill-mode to
         ;; prevent it.
         (auto-fill-mode 1)
         ;; i don't need to know fill mode is going
         (diminish 'auto-fill-mode)
         (diminish 'auto-fill-function)
         (setq org-latex-listings t)
         ;; reminder you can always use luatex as an alt in case xetex is giving
         ;; issues. i have found this to work with utf8 problems before.
         (setq org-latex-compiler "xetex")
         (setq org-latex-pdf-process '("xelatex -shell-escape %f"
                                       "xelatex -shell-escape %f"
                                       "xelatex -shell-escape %f"))
         (setq org-hide-emphasis-markers t)
         (prettify-symbols-mode 1)
         (set-fill-column 100))
       (add-hook 'org-mode-hook 'generic-org-minor-modes)


       ;; enable org to evaluate the following PL code blocks with C-c C-c
       ;; one of the many cool things you can use org-mode for!
       (org-babel-do-load-languages
        'org-babel-load-languages '((C . t)
                                    (python . t)
                                    (shell . t)
                                    (haskell . t)
                                    (emacs-lisp . t)
                                    (clojure . t)
                                    ;; TODO figure out how to get rust. there's at least one solution out there: https://gitlab.com/ajyoon/ob-rust
                                    (js . t)))
      #+END_SRC

      now also enable jsx for codeblocks:
      #+begin_src emacs-lisp
        (add-to-list 'org-src-lang-modes (cons "jsx" 'js-jsx))
      #+end_src
                                    
***** org-html-export-to-html and fci mode fix
      the way org-mode handles exporting blocks to html is to handle them via =(funcall lang-mode)=,
      which triggers =fci-mode=. the fci indicators then get added into the exported html and cause
      really weird looking and invalid unicode characters. 

      this is the [[https://github.com/alpaker/Fill-Column-Indicator/issues/45#issuecomment-108911964][fix prescribed from the open issue on fci-mode's repo]]:
      #+begin_src emacs-lisp
        (defun fci-mode-override-advice (&rest args))
        (advice-add 'org-html-fontify-code :around
                    (lambda (fun &rest args)
                      (advice-add 'fci-mode :override #'fci-mode-override-advice)
                      (let ((result  (apply fun args)))
                        (advice-remove 'fci-mode #'fci-mode-override-advice)
                        result)))
      #+end_src

      an alternative solution was also cross-posted on to sx ([[https://emacs.stackexchange.com/a/44577][for future reference]]).
***** org-mode tex notes

      Here's what org-latex-pdf-process is currently by default (idk if set by other mode or not, but
      for preservation):
      #+BEGIN_SRC emacs-lisp :tangle no
        ;; TODO: figure out if this will respect the default engine when set to xelatex or luatex
        ;; TODO: then figure out if that behavior will hold when exported from org-mode for compilation
        ("%latex -interaction nonstopmode -output-directory %o %f" "%latex -interaction nonstopmode -output-directory %o %f" "%latex -interaction nonstopmode -output-directory %o %f")
      #+END_SRC

      Here's an attempt at a config that allows bibtex for future reference
     
      #+BEGIN_SRC emacs-lisp :tangle no
        (setq org-latex-to-pdf-process (list "latexmk -pdflatex='xelatex -shell-escape -interaction nonstopmode' -pdf -bibtex -f %f"))
        (setq org-latex-pdf-process (list "latexmk -pdflatex='xelatex -shell-escape -interaction nonstopmode' -pdf -bibtex -f %f"))
        ;; alternatives? 
        ;; (setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
        ;; (setq org-latex-to-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
      #+END_SRC

***** org journal
      i use org-journal as a driver for my ~daily journal writing. nothing
      special about how i use it in-of-itself, given i now handle encryption
      via keybase's git hooks. i used to encrypt it locally, but i've decided
      that if you have local access to my machine, local encryption does
      little-to-nothing to protect me from you reading about my melancholy and
      existential ennui.
      #+BEGIN_SRC emacs-lisp
        (use-package org-journal
          :ensure t
          :defer t
          :custom
          (org-journal-dir "~/org/journal/"))

        ;; customize-set-variable is recommended over setq for org-journal
        ;; (customize-set-variable org-journal-dir "~/org/journal/")



        ;; stops org-journal from opening previous day's entry
        ;; (setq org-journal-carryover-items nil)
      #+END_SRC
***** org pomodoro
      org-pomodoro is a minor mode that integrates the pomodoro technique into
      org-mode's clocking mechanism. i use it a lot.
      #+BEGIN_SRC emacs-lisp
        (use-package org-pomodoro
          :init
          (setq org-pomodoro-length 30)
          (setq org-pomodoro-manual-break t)
          (setq org-pomodoro-clock-break t)
          (setq org-pomodoro-overtime-sound-p t)
          ;; TODO find a way to set an interval alarm that sets of every X minutes after
          ;; entering overtime to remind to clock into/take a break.
          ;; (setq org-pomodoro-overtime-sound
          ;;       (concat (expand-file-name
          ;;                (concat user-emacs-directory
          ;;                        "resources/freesound-org-338148__artordie__ding-REPEAT-4.wav"))))
          (setq org-pomodoro-ticking-sound-p t)
          (setq org-pomodoro-long-break-frequency 4))
      #+END_SRC
***** misc settings
      org bullets is a minor mode that lets you have pretty header symbols.
      #+BEGIN_SRC emacs-lisp
        ;; other symbols that might be of use idk:
        ;; ‚óè ‚óº ‚Åç ‚óô ‚óØ ‚ñ° ‚óé ‚ó™ ‚ñÜ ‚ñÖ ‚ñà ‚®Ä ‚®Å ‚®Ç ‚ú± ‚è£ ‚ãô ‚Éü
        ;; ‚ú≤ ‚ú∫ ‚úπ ‚ú∏ ‚úΩ ‚úª ‚úø ‚û§ ‚û° ‚ûî ‚ú™ ‚úú ‚úö ‚úô ‚ñ¢ ‚ßê ‚ñ∑ ‚óÜ
        (setq org-bullets-bullet-list (quote ("‚¨õ" "‚¨§" "‚ñ£" "‚¶ø" "‚ñ∫" "‚óº" "‚óè" "‚û§" "‚ñ°" "‚óØ" "‚óÜ")))
        ;; (setq org-hide-emphasis-markers t)
      #+END_SRC

      speaking of lists and bullets, turns out that you can also make org-mode automatically
      alternate between ordered and un-ordered bullet items between list levels so you don't have
      nested lists all with the same list style which, imho, makes them hard to read/discern by item
      level.

      #+BEGIN_SRC emacs-lisp
        (setq org-list-demote-modify-bullet '(
                                              ("-" . "+")
                                              ("+" . "*")
                                              ("*" . "-")
                                              ("A." . "1.")
                                              ("1." . "a)")
                                              ("a)" . "-")
                                              ))
      #+END_SRC

***** beginning of line behavior
      =C-a= will behave identical to =M-m= by default, meaning instead of going
      to the start of a heading, you will go to the first asterisk in a
      heading. This setting changes that behavior to cycle between the first
      character of a heading to the literal start of a line in a
      header. Additionally, it changes =C-e= to respect tags as well and cycles
      in a similar manner.

      #+BEGIN_SRC emacs-lisp
        (setq org-special-ctrl-a/e t)
      #+END_SRC
***** internal links
      This makes linking to other headlines in files more
      straightforward.
      #+BEGIN_SRC emacs-lisp
        (setq org-link-search-must-match-exact-headline nil)
      #+END_SRC
***** Stopping invisible edits
      It is really really hard sometimes to know what, and if, I've edited my
      org files when my carat is hidden. This stops that.

      #+BEGIN_SRC emacs-lisp
        (setq org-catch-invisible-edits 'error)
      #+END_SRC
***** TODO modules
      #+BEGIN_SRC emacs-lisp
        (add-to-list 'org-modules 'org-habit)
        (add-to-list 'org-modules 'org-tempo)
        (require 'org-tempo)
        (require 'org-habit)
      #+END_SRC
***** GDT Methodology
      I use org mode to store a lot of random tidbits of information. Too much
      information, actually. TODO's with vacuous deadlines, TODOs that should
      actually be done tomorrow, things I'll realistically never get around to
      in my mortal lifetime, and various bits of information inbetween.

      As a result, I try to follow the Getting Things Done methodology. While I
      don't really believe in silver bullets for organization, the skeleton of
      this system tends to work well for me. I've taken inspiration from [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][Petton]]
      and [[http://doc.norang.ca/org-mode.html][Hansen]].

****** Keybindings
       I have =C-c c= for =org-capture=, which allows me to file any random
       thing that comes across my mind or desk.

       #+BEGIN_SRC emacs-lisp
         (global-set-key (kbd "C-c c") 'org-capture)
       #+END_SRC

       I don't need to edit what agenda files I will be using on the fly, so
       disabling =C-c [= and =C-c ]= saves me grief.

       #+begin_SRC emacs-lisp
         ;; TODO
         ;; decide how to go about unbinding w/o making my kbd's break like this does.

         ;; Disable keys in org-mode
         ;;    C-c [
         ;;    C-c ]
         ;; (add-hook 'org-mode-hook
         ;;           '(lambda ()
         ;;              ;; Undefine C-c [ and C-c ] since this breaks my
         ;;              ;; org-agenda files when directories are include It
         ;;              ;; expands the files in the directories individually
         ;;              (org-defkey org-mode-map "\C-c[" 'undefined)
         ;;              (org-defkey org-mode-map "\C-c]" 'undefined))
         ;;           'append)
       #+END_SRC

****** Org exports
       i use org-mode for tons of pdf stuff and so waiting a long time is not ideal. this should
       theoretically make it async.
       #+begin_src emacs-lisp
       ;; TODO
       ;; https://stackoverflow.com/a/23192928
       #+end_src
****** Org Agenda
       Here are the files I will be using to sort and organize my tasks:
       #+BEGIN_SRC emacs-lisp
         (setq org-agenda-files '("~/org/inbox.org"
                                  "~/org/tasks.org"))
       #+END_SRC

       You can also tell Org mode your lat/long to get sunrise/sunset times to
       further enable your seasonal affective disorder. I do that here.

       #+BEGIN_SRC emacs-lisp
         (setq calendar-longitude -94.5786)
         (setq calendar-latitude 39.0997)
         (setq calendar-location-name "Kansas City")
       #+END_SRC

****** Org TODOs

       Here are the states that a TODO can have in my org config:

       #+BEGIN_SRC emacs-lisp
         (setq org-todo-keywords
               (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                       (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

       #+END_SRC

       I don't want to see the history of TODO state changes. This gets especially egregious for
       things like habits or things that generally repeat for long periods of time (once a week over
       years, etc).

       #+BEGIN_SRC emacs-lisp
         (setq org-log-into-drawer t)
       #+END_SRC


       I slightly tweak the default color settings for the faces of these
       states:

       #+BEGIN_SRC emacs-lisp
         (setq org-todo-keyword-faces
               (quote (("TODO" :foreground "red" :weight bold)
                       ("NEXT" :foreground "blue" :weight bold)
                       ("DONE" :foreground "forest green" :weight bold)
                       ("WAITING" :foreground "orange" :weight bold)
                       ("HOLD" :foreground "magenta" :weight bold)
                       ("CANCELLED" :foreground "forest green" :weight bold)
                       ("MEETING" :foreground "red" :weight bold)
                       ("PHONE" :foreground "red" :weight bold))))
       #+END_SRC

       Lets me use fast selection to swap through states of my TODOs:

       #+BEGIN_SRC emacs-lisp
         (setq org-use-fast-todo-selection t)
       #+END_SRC

       Disable ability to change these states via =S-left= and =S-right=:

       #+BEGIN_SRC emacs-lisp
         (setq org-treat-S-cursor-todo-selection-as-state-change nil)
       #+END_SRC

****** Capture Templates

       We'll file every captured moment into my inbox:

       #+BEGIN_SRC emacs-lisp
         (setq org-default-notes-file "~/org/inbox.org")
       #+END_SRC

       List of templates to choose from when capturing a moment via =C-c c=:

       #+BEGIN_SRC emacs-lisp
         ;; Capture templates for: TODO tasks, Notes, appointments, phone calls, meetings, and org-protocol
         (setq org-capture-templates
               (quote (("t" "todo" entry (file "~/org/inbox.org")
                        "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
                       ("a" "templates for anki cards")
                       ("ab" "basic card" entry (file "~/org/inbox.org")
                        "* %^{note heading} \n :PROPERTIES:\n :ANKI_NOTE_TYPE: Basic\n :END:\n** Front\n** Back\n")
                       ("ac" "cloze card" entry (file "~/org/inbox.org")
                        "* %^{note heading} \n :PROPERTIES:\n :ANKI_NOTE_TYPE: Cloze\n :END:\n** Text\n** Extra\n")
                       ("r" "respond" entry (file "~/org/inbox.org")
                        "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in :clock-resume t :immediate-finish t)
                       ("n" "note" entry (file "~/org/inbox.org")
                        "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
                       ("i" "templates for ideas")
                       ;; random
                       ("ir" "random idea" entry (file "~/org/inbox.org")
                        "* %? :IDEAS:\n%U\n%a\n" :clock-in t :clock-resume t)
                       ("ib" "blostpost idea" entry (file "~/org/inbox.org")
                        "* %? :IDEAS:BLOGPOST:\n%U\n%a\n" :clock-in t :clock-resume t)
                       ("ip" "project idea" entry (file "~/org/inbox.org")
                        "* %? :IDEAS:PROJECT:\n%U\n%a\n" :clock-in t :clock-resume t)
                       ;; ("j" "Journal" entry (file+datetree "~/git/org/diary.org")
                       ;;  "* %?\n%U\n" :clock-in t :clock-resume t)
                       ;; ("w" "org-protocol" entry (file "~/org/inbox.org")
                       ;;  "* TODO Review %c\n%U\n" :immediate-finish t)
                       ("m" "Meeting" entry (file "~/org/inbox.org")
                        "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
                       ("p" "Phone call" entry (file "~/org/inbox.org")
                        "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
                       ;; ("h" "Habit" entry (file "~/org/inbox.org")
                       ;;  "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")
                       )))
       #+END_SRC

       My refile targets for moments. Ideally, I should actively be refiling
       things from my inbox to where they belong. If they are something I will
       be working on, big or small, they go to tasks. If it's just an
       idea/something I won't be touching for sometime, then thoughts. Etc.

       #+BEGIN_SRC emacs-lisp
         ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
         (setq org-refile-targets '(("~/org/tasks.org" :maxlevel . 9)
                                    ("~/org/later.org" :maxlevel . 9)
                                    ("~/org/reference.org" :maxlevel . 9)
                                    ("~/org/anki/anki.org" :maxlevel . 9)
                                    ))

         ; Allow refile to create parent tasks with confirmation
         (setq org-refile-allow-creating-parent-nodes (quote confirm))
       #+END_SRC

       We don't want to include DONE tasks as refile targets because that will
       make our lists *huge*.

       #+BEGIN_SRC emacs-lisp
         ;;;; Refile settings
         ; Exclude DONE state tasks from refile targets
         (defun bh/verify-refile-target ()
           "Exclude todo keywords with a done state from refile targets"
           (not (member (nth 2 (org-heading-components)) org-done-keywords)))

         (setq org-refile-target-verify-function 'bh/verify-refile-target)
       #+END_SRC

****** TODO Agenda View
       #+BEGIN_SRC emacs-lisp
         ;; Do not dim blocked tasks
         (setq org-agenda-dim-blocked-tasks nil)

         ;; Compact the block agenda view
         (setq org-agenda-compact-blocks t)

         ;; Custom agenda command definitions
         (setq org-agenda-custom-commands
               (quote (("N" "Notes" tags "NOTE"
                        ((org-agenda-overriding-header "Notes")
                         (org-tags-match-list-sublevels t)))
                       ("h" "Habits" tags-todo "STYLE=\"habit\""
                        ((org-agenda-overriding-header "Habits")
                         (org-agenda-sorting-strategy
                          '(todo-state-down effort-up category-keep))))
                       (" " "Agenda"
                        ((agenda "" nil)
                         (tags "REFILE"
                               ((org-agenda-overriding-header "Tasks to Refile")
                                (org-tags-match-list-sublevels nil)))
                         (tags-todo "-CANCELLED/!"
                                    ((org-agenda-overriding-header "Stuck Projects")
                                     (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                                     (org-agenda-sorting-strategy
                                      '(category-keep))))
                         (tags-todo "-HOLD-CANCELLED/!"
                                    ((org-agenda-overriding-header "Projects")
                                     (org-agenda-skip-function 'bh/skip-non-projects)
                                     (org-tags-match-list-sublevels 'indented)
                                     (org-agenda-sorting-strategy
                                      '(category-keep))))
                         (tags-todo "-CANCELLED/!NEXT"
                                    ((org-agenda-overriding-header (concat "Project Next Tasks"
                                                                           (if bh/hide-scheduled-and-waiting-next-tasks
                                                                               ""
                                                                             " (including WAITING and SCHEDULED tasks)")))
                                     (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                                     (org-tags-match-list-sublevels t)
                                     (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-sorting-strategy
                                      '(todo-state-down effort-up category-keep))))
                         (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                                    ((org-agenda-overriding-header (concat "Project Subtasks"
                                                                           (if bh/hide-scheduled-and-waiting-next-tasks
                                                                               ""
                                                                             " (including WAITING and SCHEDULED tasks)")))
                                     (org-agenda-skip-function 'bh/skip-non-project-tasks)
                                     (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-sorting-strategy
                                      '(category-keep))))
                         (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                                    ((org-agenda-overriding-header (concat "Standalone Tasks"
                                                                           (if bh/hide-scheduled-and-waiting-next-tasks
                                                                               ""
                                                                             " (including WAITING and SCHEDULED tasks)")))
                                     (org-agenda-skip-function 'bh/skip-project-tasks)
                                     (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-sorting-strategy
                                      '(category-keep))))
                         (tags-todo "-CANCELLED+WAITING|HOLD/!"
                                    ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                                           (if bh/hide-scheduled-and-waiting-next-tasks
                                                                               ""
                                                                             " (including WAITING and SCHEDULED tasks)")))
                                     (org-agenda-skip-function 'bh/skip-non-tasks)
                                     (org-tags-match-list-sublevels nil)
                                     (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)))
                         (tags "-REFILE/"
                               ((org-agenda-overriding-header "Tasks to Archive")
                                (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                                (org-tags-match-list-sublevels nil))))
                        nil))))

       #+END_SRC
****** TODO Project Management/View
       #+BEGIN_SRC emacs-lisp
         (setq org-stuck-projects (quote ("" nil nil "")))
       #+END_SRC

       #+BEGIN_SRC emacs-lisp
         (defun bh/is-project-p ()
           "Any task with a todo keyword subtask"
           (save-restriction
             (widen)
             (let ((has-subtask)
                   (subtree-end (save-excursion (org-end-of-subtree t)))
                   (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
               (save-excursion
                 (forward-line 1)
                 (while (and (not has-subtask)
                             (< (point) subtree-end)
                             (re-search-forward "^\*+ " subtree-end t))
                   (when (member (org-get-todo-state) org-todo-keywords-1)
                     (setq has-subtask t))))
               (and is-a-task has-subtask))))

         (defun bh/is-project-subtree-p ()
           "Any task with a todo keyword that is in a project subtree.
         Callers of this function already widen the buffer view."
           (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                       (point))))
             (save-excursion
               (bh/find-project-task)
               (if (equal (point) task)
                   nil
                 t))))

         (defun bh/is-task-p ()
           "Any task with a todo keyword and no subtask"
           (save-restriction
             (widen)
             (let ((has-subtask)
                   (subtree-end (save-excursion (org-end-of-subtree t)))
                   (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
               (save-excursion
                 (forward-line 1)
                 (while (and (not has-subtask)
                             (< (point) subtree-end)
                             (re-search-forward "^\*+ " subtree-end t))
                   (when (member (org-get-todo-state) org-todo-keywords-1)
                     (setq has-subtask t))))
               (and is-a-task (not has-subtask)))))

         (defun bh/is-subproject-p ()
           "Any task which is a subtask of another project"
           (let ((is-subproject)
                 (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
             (save-excursion
               (while (and (not is-subproject) (org-up-heading-safe))
                 (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                   (setq is-subproject t))))
             (and is-a-task is-subproject)))

         (defun bh/list-sublevels-for-projects-indented ()
           "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
           This is normally used by skipping functions where this variable is already local to the agenda."
           (if (marker-buffer org-agenda-restrict-begin)
               (setq org-tags-match-list-sublevels 'indented)
             (setq org-tags-match-list-sublevels nil))
           nil)

         (defun bh/list-sublevels-for-projects ()
           "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
           This is normally used by skipping functions where this variable is already local to the agenda."
           (if (marker-buffer org-agenda-restrict-begin)
               (setq org-tags-match-list-sublevels t)
             (setq org-tags-match-list-sublevels nil))
           nil)

         (defvar bh/hide-scheduled-and-waiting-next-tasks t)

         (defun bh/toggle-next-task-display ()
           (interactive)
           (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
           (when  (equal major-mode 'org-agenda-mode)
             (org-agenda-redo))
           (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

         (defun bh/skip-stuck-projects ()
           "Skip trees that are not stuck projects"
           (save-restriction
             (widen)
             (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
               (if (bh/is-project-p)
                   (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                          (has-next ))
                     (save-excursion
                       (forward-line 1)
                       (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                         (unless (member "WAITING" (org-get-tags-at))
                           (setq has-next t))))
                     (if has-next
                         nil
                       next-headline)) ; a stuck project, has subtasks but no next task
                 nil))))

         (defun bh/skip-non-stuck-projects ()
           "Skip trees that are not stuck projects"
           ;; (bh/list-sublevels-for-projects-indented)
           (save-restriction
             (widen)
             (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
               (if (bh/is-project-p)
                   (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                          (has-next ))
                     (save-excursion
                       (forward-line 1)
                       (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                         (unless (member "WAITING" (org-get-tags-at))
                           (setq has-next t))))
                     (if has-next
                         next-headline
                       nil)) ; a stuck project, has subtasks but no next task
                 next-headline))))

         (defun bh/skip-non-projects ()
           "Skip trees that are not projects"
           ;; (bh/list-sublevels-for-projects-indented)
           (if (save-excursion (bh/skip-non-stuck-projects))
               (save-restriction
                 (widen)
                 (let ((subtree-end (save-excursion (org-end-of-subtree t))))
                   (cond
                    ((bh/is-project-p)
                     nil)
                    ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
                     nil)
                    (t
                     subtree-end))))
             (save-excursion (org-end-of-subtree t))))

         (defun bh/skip-non-tasks ()
           "Show non-project tasks.
         Skip project and sub-project tasks, habits, and project related tasks."
           (save-restriction
             (widen)
             (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
               (cond
                ((bh/is-task-p)
                 nil)
                (t
                 next-headline)))))

         (defun bh/skip-project-trees-and-habits ()
           "Skip trees that are projects"
           (save-restriction
             (widen)
             (let ((subtree-end (save-excursion (org-end-of-subtree t))))
               (cond
                ((bh/is-project-p)
                 subtree-end)
                ((org-is-habit-p)
                 subtree-end)
                (t
                 nil)))))

         (defun bh/skip-projects-and-habits-and-single-tasks ()
           "Skip trees that are projects, tasks that are habits, single non-project tasks"
           (save-restriction
             (widen)
             (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
               (cond
                ((org-is-habit-p)
                 next-headline)
                ((and bh/hide-scheduled-and-waiting-next-tasks
                      (member "WAITING" (org-get-tags-at)))
                 next-headline)
                ((bh/is-project-p)
                 next-headline)
                ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
                 next-headline)
                (t
                 nil)))))

         (defun bh/skip-project-tasks-maybe ()
           "Show tasks related to the current restriction.
         When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
         When not restricted, skip project and sub-project tasks, habits, and project related tasks."
           (save-restriction
             (widen)
             (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                    (next-headline (save-excursion (or (outline-next-heading) (point-max))))
                    (limit-to-project (marker-buffer org-agenda-restrict-begin)))
               (cond
                ((bh/is-project-p)
                 next-headline)
                ((org-is-habit-p)
                 subtree-end)
                ((and (not limit-to-project)
                      (bh/is-project-subtree-p))
                 subtree-end)
                ((and limit-to-project
                      (bh/is-project-subtree-p)
                      (member (org-get-todo-state) (list "NEXT")))
                 subtree-end)
                (t
                 nil)))))

         (defun bh/skip-project-tasks ()
           "Show non-project tasks.
         Skip project and sub-project tasks, habits, and project related tasks."
           (save-restriction
             (widen)
             (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
               (cond
                ((bh/is-project-p)
                 subtree-end)
                ((org-is-habit-p)
                 subtree-end)
                ((bh/is-project-subtree-p)
                 subtree-end)
                (t
                 nil)))))

         (defun bh/skip-non-project-tasks ()
           "Show project tasks.
         Skip project and sub-project tasks, habits, and loose non-project tasks."
           (save-restriction
             (widen)
             (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                    (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
               (cond
                ((bh/is-project-p)
                 next-headline)
                ((org-is-habit-p)
                 subtree-end)
                ((and (bh/is-project-subtree-p)
                      (member (org-get-todo-state) (list "NEXT")))
                 subtree-end)
                ((not (bh/is-project-subtree-p))
                 subtree-end)
                (t
                 nil)))))

         (defun bh/skip-projects-and-habits ()
           "Skip trees that are projects and tasks that are habits"
           (save-restriction
             (widen)
             (let ((subtree-end (save-excursion (org-end-of-subtree t))))
               (cond
                ((bh/is-project-p)
                 subtree-end)
                ((org-is-habit-p)
                 subtree-end)
                (t
                 nil)))))

         (defun bh/skip-non-subprojects ()
           "Skip trees that are not projects"
           (let ((next-headline (save-excursion (outline-next-heading))))
             (if (bh/is-subproject-p)
                 nil
               next-headline)))
       #+END_SRC
****** TODO clock
       Sometimes I like having the total time shown be only for the current
       session of a task. When I want that, set this to ='current=.
       #+BEGIN_SRC emacs-lisp
         (setq org-clock-mode-line-total 'auto)
       #+END_SRC

       #+BEGIN_SRC emacs-lisp
         ;; Resume clocking task when emacs is restarted
         ;; (org-clock-persistence-insinuate)
         ;;
         ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
         (setq org-clock-history-length 23)
         ;; Resume clocking task on clock-in if the clock is open
         ;; (setq org-clock-in-resume t)
         ;; Change tasks to NEXT when clocking in
         (setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
         ;; Separate drawers for clocking and logs
         ;; (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
         ;; Save clock data and state changes and notes in the LOGBOOK drawer
         ;; (setq org-clock-into-drawer t)
         ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
         (setq org-clock-out-remove-zero-time-clocks t)
         ;; Clock out when moving task to a done state
         (setq org-clock-out-when-done t)
         ;; Save the running clock and all clock history when exiting Emacs, load it on startup
         (setq org-clock-persist t)
         ;; Do not prompt to resume an active clock
         (setq org-clock-persist-query-resume nil)
         ;; Enable auto clock resolution for finding open clocks
         ;; (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
         ;; Include current clocking task in clock reports
         (setq org-clock-report-include-clocking-task t)

         (setq bh/keep-clock-running nil)

         (defun bh/clock-in-to-next (kw)
           "Switch a task from TODO to NEXT when clocking in.
         Skips capture tasks, projects, and subprojects.
         Switch projects and subprojects from NEXT back to TODO"
           (when (not (and (boundp 'org-capture-mode) org-capture-mode))
             (cond
              ((and (member (org-get-todo-state) (list "TODO"))
                    (bh/is-task-p))
               "NEXT")
              ((and (member (org-get-todo-state) (list "NEXT"))
                    (bh/is-project-p))
               "TODO"))))

         (defun bh/find-project-task ()
           "Move point to the parent (project) task if any"
           (save-restriction
             (widen)
             (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
               (while (org-up-heading-safe)
                 (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                   (setq parent-task (point))))
               (goto-char parent-task)
               parent-task)))

         (defun bh/punch-in (arg)
           "Start continuous clocking and set the default task to the
         selected task.  If no task is selected set the Organization task
         as the default task."
           (interactive "p")
           (setq bh/keep-clock-running t)
           (if (equal major-mode 'org-agenda-mode)
               ;;
               ;; We're in the agenda
               ;;
               (let* ((marker (org-get-at-bol 'org-hd-marker))
                      (tags (org-with-point-at marker (org-get-tags-at))))
                 (if (and (eq arg 4) tags)
                     (org-agenda-clock-in '(16))
                   (bh/clock-in-organization-task-as-default)))
             ;;
             ;; We are not in the agenda
             ;;
             (save-restriction
               (widen)
               ; Find the tags on the current task
               (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
                   (org-clock-in '(16))
                 (bh/clock-in-organization-task-as-default)))))

         (defun bh/punch-out ()
           (interactive)
           (setq bh/keep-clock-running nil)
           (when (org-clock-is-active)
             (org-clock-out))
           (org-agenda-remove-restriction-lock))

         (defun bh/clock-in-default-task ()
           (save-excursion
             (org-with-point-at org-clock-default-task
               (org-clock-in))))

         (defun bh/clock-in-parent-task ()
           "Move point to the parent (project) task if any and clock in"
           (let ((parent-task))
             (save-excursion
               (save-restriction
                 (widen)
                 (while (and (not parent-task) (org-up-heading-safe))
                   (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                     (setq parent-task (point))))
                 (if parent-task
                     (org-with-point-at parent-task
                       (org-clock-in))
                   (when bh/keep-clock-running
                     (bh/clock-in-default-task)))))))

         (defvar bh/organization-task-id "eb155a82-92b2-4f25-a3c6-0304591af2f9")

         (defun bh/clock-in-organization-task-as-default ()
           (interactive)
           (org-with-point-at (org-id-find bh/organization-task-id 'marker)
             (org-clock-in '(16))))

         (defun bh/clock-out-maybe ()
           (when (and bh/keep-clock-running
                      (not org-clock-clocking-in)
                      (marker-buffer org-clock-default-task)
                      (not org-clock-resolving-clocks-due-to-idleness))
             (bh/clock-in-parent-task)))

         (add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)
       #+END_SRC
****** Displaying the clock
       I want to be able to see my clocked time in as many places as
       possible. This makes sure I see it both in the mode-line and the frame
       title. I have it this way because if the frame/window is small enough,
       the clock in the mode-line will be cut off, with emacs preferring to
       display major-mode and minor-mode information instead. Until I fix that
       behavior, this provides a good compromise:

       #+BEGIN_SRC emacs-lisp
         (setq org-clock-clocked-in-display 'both)
       #+END_SRC
****** reminders of tasks
       Secretaria is a minor mode that will remind you of things currently
       scheduled for the day in addition to the task you are supposed to be
       working on.
       #+BEGIN_SRC emacs-lisp
         (use-package secretaria
           :config
           ;; use this for getting a reminder every 30 minutes of those tasks scheduled
           ;; for today and which have no time of day defined.
           (add-hook 'after-init-hook #'secretaria-unknown-time-always-remind-me))
       #+END_SRC
***** archiving tasks
      Settings
      #+BEGIN_SRC emacs-lisp
        (setq org-archive-mark-done nil)
        (setq org-archive-location "%s_archive::* Archived Tasks")
      #+END_SRC

      Function behavior
      #+BEGIN_SRC emacs-lisp
        (defun bh/skip-non-archivable-tasks ()
          "Skip trees that are not available for archiving"
          (save-restriction
            (widen)
            ;; Consider only tasks with done todo headings as archivable candidates
            (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
                  (subtree-end (save-excursion (org-end-of-subtree t))))
              (if (member (org-get-todo-state) org-todo-keywords-1)
                  (if (member (org-get-todo-state) org-done-keywords)
                      (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                             (a-month-ago (* 60 60 24 (+ daynr 1)))
                             (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                             (this-month (format-time-string "%Y-%m-" (current-time)))
                             (subtree-is-current (save-excursion
                                                   (forward-line 1)
                                                   (and (< (point) subtree-end)
                                                        (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                        (if subtree-is-current
                            subtree-end ; Has a date in this month or last month, skip it
                          nil))  ; available to archive
                    (or subtree-end (point-max)))
                next-headline))))
      #+END_SRC
***** org-download
      #+BEGIN_SRC emacs-lisp
        (use-package org-download)
        (setq org-image-actual-width 600)
      #+END_SRC
**** erc

     #+BEGIN_SRC emacs-lisp

        ;; Load authentication info from an external source.  Put sensitive
       ;; passwords and the like in here.

       (require 'erc)
       (load "~/.emacs.d/.erc-auth")
       (require 'erc-services)
       (erc-services-mode 1)

       (setq erc-prompt-for-nickserv-password nil)

       (setq erc-nick '("ejmg"))

       (setq erc-nickserv-passwords
             '((freenode     (("ejmg"  . erc-freenode-ejmg-pass)))))

       ;; This causes ERC to connect to the Freenode network upon hitting
       ;; C-c e f.  Replace MYNICK with your IRC nick.

       ;; TODO: FIGURE OUT SASL SUPPORT so I can use VPN + IRC
       ;; (defun login-erc-tls ()
       ;;   "Log in to irc using ssl."
       ;;   (interactive)
       ;;   (erc-tls :server "irc.freenode.net"
       ;;            :port "6697"
       ;;            :nick "[spook]"))

       ;; (global-set-key "\C-cef" #'login-erc-tls)

       ;; (defun login-erc ()
       ;;   "login to irc w/o ssl"
       ;;   (interactive)
       ;;   (erc :server "irc.freenode.net"
       ;;        :port "6667"
       ;;        :nick "[spook]")
       ;;   :password spook-password)



       ;; Rename server buffers to reflect the current network name instead
       ;; of SERVER:PORT (e.g., "freenode" instead of "irc.freenode.net:6667").
       ;; This is useful when using a bouncer like ZNC where you have multiple
       ;; connections to the same server.
       (setq erc-rename-buffers t)

       ;; Interpret mIRC-style color commands in IRC chats
       (setq erc-interpret-mirc-color t)
     #+END_SRC
**** matrix chat
     matrix is popular these days as an alt to both irc and slack, so here's a nice package that
     lets me run it with emacs. it's not on melpa, which is why quelpa is necessary for this one.

     #+BEGIN_SRC emacs-lisp
       (use-package matrix-client
         :quelpa (matrix-client :fetcher github :repo "alphapapa/matrix-client.el"
                                :files (:defaults "logo.png" "matrix-client-standalone.el.sh")))
     #+END_SRC

**** sx mode
     =sx= is a really awesome mode that lets you search stackexchange via their API. It's essentially
     native support in emacs because of how the author implemented it, which is super nice.
     #+BEGIN_SRC emacs-lisp
       (use-package sx)
     #+END_SRC
**** vlc-rc
     [[https://github.com/MoHKale/vlc-rc][vlc-rc]] is a nice mode that lets you control vlc when you
     enable its remote control interface. run =vlc= and it'll give you a set of options + kick off a
     vlc instance that it is correctly connected to.
     #+BEGIN_SRC emacs-lisp
       (require 'vlc-rc)
     #+END_SRC
**** eww
     So I've started to unironically use, and enjoy, emacs' built in web browser, =eww=. Websites that
     are heavily reliant on js won't work well with it, but the reality is i already avoid websites
     like that and, for what i use eww, encountering js is even less of an issue.

***** disabling images by default
      eww works well even on a bad connection, but doesn't cache things like images
      automatically. this makes refreshing annoying when on a bad connection, and i typically don't
      want the images anyway for what i use eww for.

      This works beautifully, very thankful to [[https://emacs.stackexchange.com/a/38639][Glucas' solution]]! 
      #+BEGIN_SRC emacs-lisp
        (defun glucas/eww-toggle-images ()
          "Toggle whether images are loaded and reload the current page from cache."
          (interactive)
          (setq-local shr-inhibit-images (not shr-inhibit-images))
          (eww-reload t)
          (message "Images are now %s"
                   (if shr-inhibit-images "off" "on")))

        ;; minimal rendering by default
        (setq-default shr-inhibit-images t)   ; toggle with `I`
        (setq-default shr-use-fonts nil)      ; toggle with `F`
      #+END_SRC

**** anki mode
     anki mode doesn't come with its own keymap, so i define one to generate better keybindings
     using general mode.
     #+BEGIN_SRC emacs-lisp
       ;; (defvar anki-editor-mode-keymap (make-keymap) "anki-editor-mode keymap")

       (defvar anki-editor-mode-map
         (let ((map (make-sparse-keymap)))
           (set-keymap-parent map org-mode-map)
           map)
         "Keymap for anki editor mode. Inherits from `org-mode-map'.")

       (defun anki-tweaks ()
         (interactive)
         (use-local-map anki-editor-mode-map))

       (add-hook 'anki-editor-mode-hook 'anki-tweaks)
     #+END_SRC
** TODO keybindings

   So this is something i really don't have a full or proper opinion on as of now. I think the idea
   of defining keybindings in each use-package declaration is kinda gross because it would mean i
   haphazardly define keybindings all over my config and i could easily re-assign old bindings
   without knowing it, etc. Simultaneously, I don't know of a better way of linking a mode's
   bindings with the mode's configurations? I guess a possible *solution* is properly organizing
   each binding declaration under a subheader for the mode it is most related to and then =C-c C-l=
   each keybinding subheading to its respective mode configuration for easy cross referencing. those
   links won't work on github, unfortunately but w/e.

   - [ ] figure out how to better organize general groups/prefix keys. i know the readme discusses
     this, e.g. how to setup a general leader key like "C-c", and then use that as a prefix
     elsewhere rather than having to re-do it for each general keybinding definition like I
     currently do below ("C-c m", "C-c e", etc).
   - [ ] figure out if there is a way to define top level binding maps/groups, i.e. "C-c m" gets
     binded to a set of keybindings for magit, and expands to the general defined key bindings
     defined, as of now, to a prefix, like ="s" 'magit-status=, ="p" 'magit-pull=, etc below.
   - [ ] need to break these up into their own subheadings and use general-define-key consistently
     instead of haphazard use of bind-key vs general-define-key, etc.
   - [ ] need to search rest of the config for one off keybinding defs and put them in this section
     under their correct subheading
   - [ ] figure out benefit of defining on-top of keymaps.  I presume it means the bindings are
     localized only to that mode's keymaps, which would be very nice and reduce noise.

*** TODO leader key
    So i think i'm going to use =M-SPC= as a local mode leader key for bindings that change based on
    the mode, i.e. cargo commands for rust, etc. It feels a bit more natural than reaching for =F11=
    or =F12= constantly, and let's me reserve those for keys that won't typically change.

    For global, I'm going to use =s-m=, super + m key, which is going to be reserved for those things
    that don't change often but I use everywhere.... I think.
    #+BEGIN_SRC emacs-lisp

      (global-unset-key (kbd "M-SPC"))
      (general-create-definer local-leader
        :prefix "M-SPC")

      (global-unset-key (kbd "s-m"))
      (general-create-definer g-leader
        :prefix "s-m")

      ;; Stolen from kbd vermiculous' docs for sx.el, who in turn stole it from
      ;; Endless Parentheses:
      ;; http://endlessparentheses.com/sx-el-announcement-and-more-launcher-map.html

      ;; (defconst launcher-map "s-l")
      (general-create-definer launcher-map
        :prefix "s-l")

      ;; (general-create-definer proj-leader
      ;;   :prefix "M-m p")
    #+END_SRC

*** TODO utility key bindings
    these are keybindings that i find myself using universally across modes and thus want to have
    ready access to. <XF86Launch1> makes a good candidate for a leader key when universal access is
    wanted w/o polluting keyspace. This is still being figured out, though, so consistency is a
    total =lol= at the moment.

**** TODO projectile
     #+BEGIN_SRC emacs-lisp
       (g-leader
         "ps" 'counsel-projectile-switch-project
         "pp" 'counsel-projectile
         "pa" 'counsel-projectile-ag
         "pf" 'counsel-find-file
         "pk" 'projectile-kill-buffers)

       (which-key-add-key-based-replacements
         "s-m p" "projectile")
     #+END_SRC

**** TODO ripgrep/searching utils
     is this truly necessary when i have counsel-projectile-ag? i think so?
**** TODO dired mode stuff
**** TODO which-key helpers
**** alarm
     Self explanatory. =alarm-clock= is a useful utility that i use all the time. quick keystroke is
     what i need.
     #+BEGIN_SRC emacs-lisp
       (launcher-map
        "as" 'alarm-clock-set
        "al" 'alarm-clock-list-view)

       ;; Not impressed by having to do this, but I can't figure out from
       ;; General's docs how to effectively get same behavior for common
       ;; prefix keys that are not individually bound to something.
       (which-key-add-key-based-replacements
         "s-l a" "alarm")
     #+END_SRC
*** TODO unsorted bindings
    these are my unsorted keybindings from before my recent reshuffling. i will be breaking them
    apart as described above.

    #+BEGIN_SRC emacs-lisp
      (global-unset-key (kbd "C-z"))

      (bind-key (kbd "M-/") 'hippie-expand)

      (general-define-key
       :prefix "C-c m"
       "s" 'magit-status
       "p" 'magit-pull
       "b" 'magit-branch
       "c" 'magit-checkout
       "d" 'magit-branch-and-checkout
       "g" 'magit-clone
       "n" 'magit-init)

      ;; Don't really use wg's that much.
      ;; wasted keybindings till I find the need.
      ;; (general-define-key
      ;;  :prefix "C-c w"
      ;;  "c" 'wg-create-workgroup
      ;;  "v" 'wg-switch-to-workgroup
      ;;  "w" 'wg-toggle-morph
      ;;  "r" 'wg-revert-workgroup
      ;;  "u" 'wg-update-workgroup
      ;;  "s" 'wg-save
      ;;  "l" 'wg-load)

      (general-define-key
       :prefix "C-c e"
       "c" 'mc/edit-lines
       ">" 'mc/mark-next-like-this
       "<" 'mc/mark-previous-like-this
       "e" 'mc/edit-ends-of-lines
       "b" 'mc/edit-beginnings-of-lines
       "a" 'mc/mark-all-like-this
       "r" 'mc/mark-all-in-region)

       ;; (general-define-key
       ;;  :prefix "C-c e"
       ;;  "t" 'login-erc-tls
       ;;  "l" 'login-erc)

       (general-define-key
        "C-~" 'ace-swap-window)

       (general-define-key
        "C-z" 'other-window)

       (general-define-key
       "C-S-z" 'ace-window)

       (which-key-add-key-based-replacements
         "C-c m" "magit"
         "C-c !" "flycheck"
         "C-c &" "yas"
         "C-c e" "mcursor"
         )

       ;; not sure if need?
       ;; (which-key-add-major-mode-key-based-replacements 'org-mode
       ;;   "C-c [" "anki")

    #+END_SRC

*** TODO org mode bindings
    I need to be able to access my agenda view quickly. This setting
    is currently made with my lenovo x1 carbon in mind. It has a function
    key, "Favorite", that is not recognized by xorg. I remapped it to the
    key =prog2= which is an alias for =XF86Launch2=.

    These are bindings I always want available, so I define them as such.

    #+BEGIN_SRC emacs-lisp
            ;;(global-set-key (kbd "<XF86Launch2>") 'org-agenda)

            (general-define-key
             :prefix "<XF86Launch2>"
             "a" 'org-agenda
             "c" 'org-clock-cancel
             "g" 'org-clock-goto
             "j" 'org-journal-new-entry
             "k" nil
             "l" 'org-clock-in-last
             "o" 'org-clock-out
             "p" 'org-pomodoro
             "r" 'org-resolve-clocks
             "s" 'org-save-all-org-buffers)

            (which-key-add-key-based-replacements "<XF86Launch2>" "org mode")
    #+END_SRC

    Other keybindings I want only while in org-mode buffers but aren't bound by default.

    #+BEGIN_SRC emacs-lisp
      (local-leader
        :keymap 'org-mode-map
        "tl" 'org-toggle-link-display)
    #+END_SRC

*** TODO spotify
    Consider rebinding the defaults provided for a better interface. This might even be a good use
    case for hydra mode, for example. I think some of the defaults are a bit too arbitrary for me vs
    what the author might have as their workflow.
    #+BEGIN_SRC emacs-lisp
      ;; TODO make spotify config stuff more organized.
      ;; (general-create-definer spotify-leader
      ;;   :prefix "M-p")

      (defun spotify-disable-mode-line ()
        (interactive)
        (setq spotify-mode-line-refresh-interval 0))

      (defun spotify-set-mode-line-refresh ()
        (interactive)
        (let* ((prompt "Set interval [seconds]:")
               (val (read-number prompt 60)))
          (setq spotify-mode-line-refresh-interval val)))

      (launcher-map
       "sc" 'spotify-remote-mode
       "sd" 'spotify-select-device
       "s SPC" 'spotify-toggle-play
       "sr" 'spotify-toggle-repeat
       "ss" 'spotify-toggle-shuffle
       "sn" 'spotify-next-track
       "sp" 'spotify-previous-track
       "smr" 'spotify-set-mode-line-refresh
       "smd" 'spotify-disable-mode-line
       "sl" 'spotify-my-playlists
       )

      (which-key-add-key-based-replacements "s-l s" "spotify")

    #+END_SRC
*** TODO sx
    #+BEGIN_SRC emacs-lisp
      (launcher-map
       "xs" 'sx-search
       "xt" 'sx-tab-all-questions)
       (which-key-add-key-based-replacements "s-l x" "sx")
    #+END_SRC
*** rust keybindings
    Basically, I just want less keystrokes to get to cargo commands. Pretty straight forward.

    First I set the keystroke =M-SPC t= to nothing globally, otherwise the rust declaration becomes
    global.

    #+BEGIN_SRC emacs-lisp
      (general-define-key
       "M-SPC t" nil
       )
    #+END_SRC

    now i provide my rust-mode local keybindings!

    #+BEGIN_SRC emacs-lisp
      (local-leader
        :keymaps 'rust-mode-map
        "b" 'cargo-process-build
        "c" 'cargo-process-check
        "C" 'cargo-process-clean
        ;; bind nothing but give M-SPC f a description for which-key
        "f" '(:ignore t :which-key "fmt")
        "ff" 'cargo-process-fmt
        "fe" 'rust-enable-format-on-save
        "fd" 'rust-disable-format-on-save
        "h" '(:ignore t :which-key "hide")
        "hb" 'hs-hide-block
        "hl" 'hs-hide-level
        "ha" 'hs-hide-all
        "hs" '(:ignore t :which-key "show")
        "hsa" 'hs-show-all
        "hsb" 'hs-show-block
        "r" 'cargo-process-run
        "t" '(:ignore t :which-key "tests")
        "tt" 'cargo-process-test
        "tc" 'cargo-process-current-test
        "tf" 'cargo-process-current-file-tests
        ;; TODO: anyway to generalize this to all programming maps?
        "e" '(:ignore t :which-key "errors")
        "ec" 'flycheck-explain-error-at-point
        "ep" 'flycheck-previous-error
        "en" 'flycheck-next-error
        )
    #+END_SRC
*** eww
    These keybindings just go with the custom function I pulled from sx and documented for [[eww][eww]]
    earlier.
*** anki-editor
    keybindings for quicker anki card editing

    #+BEGIN_SRC emacs-lisp
      (local-leader
       :keymaps 'anki-editor-mode-map
       "n" 'anki-editor-insert-note
       "r" 'anki-editor-retry-failure-notes
       "s" 'anki-editor-push-notes
       "c" 'anki-editor-cloze-region)
    #+END_SRC
** Languages
*** General

    configurations that apply generally to prog-modes and that aren't already
    handled in other categories.

    #+BEGIN_SRC emacs-lisp

      (defun my-add-watchwords ()
        "Highlight FIXME, TODO, NOTE, and NOCOMMIT in code"
        (font-lock-add-keywords
         nil '(("\\<\\(FIXME\\|TODO\\|NOTE\\|NOCOMMIT\\)\\>"
                1 '((:foreground "#d7a3ad") (:weight bold)) t))))

      (add-hook 'prog-mode-hook 'my-add-watchwords)

      (defun things-all-prog-modes-should-do-dot-jay-peg ()
        "Name specifies function: things all prog modes should have."
        (interactive)
        (fci-mode)
        (linum-mode)
        (emojify-mode)
        (smartparens-mode)
        ;;(yas-reload-all)
        ;;(yas-minor-mode-on)
        (show-paren-mode))

      (add-hook 'prog-mode-hook 'things-all-prog-modes-should-do-dot-jay-peg)
    #+END_SRC
*** Haskell

    #+BEGIN_SRC emacs-lisp
      (use-package haskell-mode
        :defer t
        :config
        (defun my-haskell-setup()
          (interactive)
          (haskell-doc-mode)
          ;; (haskell-indent-mode)
          ;; (haskell-indent-offset 2)
          (flycheck-haskell-setup)
          (electric-indent-mode 0) ;; currently causes a 'cl--assertion-failed: assertion failed (<= start end)'
          ;; (setq haskell-indent-offset 2)
          (interactive-haskell-mode)
          (hindent-mode) ;; must install with stack
          (haskell-snippets-initialize)
          ;; Warning, not picked up by non-daemon emacs for some reason?
          ;; Is configured as 'auto' for some reason.
          ;; (setq haskell-compile-cabal-build-command "stack build --fast")
          (setq haskell-process-type 'stack-ghci)))
      (add-hook 'haskell-mode-hook 'my-haskell-setup)

    #+END_SRC
**** Interactive Haskell Mode
***** Fix for irrelevant error message.
      Seems that haskell-mode generally suffers from a plethora of bugs due
      lagging support/impl features for newer features of GHC. It appears this
      is one such bug. [[https://github.com/haskell/haskell-mode/issues/1553][Github Issue]].

      The solution is just adding some extra flags to be passed on to ghci,
      etc. From the commentary, the solution might be *incompatible with older
      versions of GHC (< 8.2)*. [[https://github.com/haskell/haskell-mode/issues/1553#issuecomment-358373643][Solution]]:
      #+BEGIN_SRC emacs-lisp
        (setq haskell-process-args-ghci
              '("-ferror-spans" "-fshow-loaded-modules"))

        (setq haskell-process-args-cabal-repl
              '("--ghc-options=-ferror-spans -fshow-loaded-modules"))

        (setq haskell-process-args-stack-ghci
              '("--ghci-options=-ferror-spans -fshow-loaded-modules"
                "--no-build" "--no-load"))

        (setq haskell-process-args-cabal-new-repl
              '("--ghc-options=-ferror-spans -fshow-loaded-modules"))
      #+END_SRC
*** python

    #+BEGIN_SRC emacs-lisp

      ;; bug fix for readline error
      (with-eval-after-load 'python
        (defun python-shell-completion-native-try ()
          "Return non-nil if can trigger native completion."
          (let ((python-shell-completion-native-enable t)
                (python-shell-completion-native-output-timeout
                 python-shell-completion-native-try-output-timeout))
            (python-shell-completion-native-get-completions
             (get-buffer-process (current-buffer))
             nil "_"))))

      (with-eval-after-load 'python
        (add-hook
         'python-mode-hook (lambda ()
                             (setq python-shell-interpreter "python3"))))

      ;; allows triple quote strings to automatically be paired by electrip-pair
      (defun python-electric-pair-string-delimiter ()
        (when (and electric-pair-mode
                   (memq last-command-event '(?\" ?\'))
                   (let ((count 0))
                     (while (eq (char-before (- (point) count)) last-command-event)
                       (setq count (1+ count)))
                     (= count 3)))
          (save-excursion (insert (make-string 3 last-command-event)))))

      (add-hook 'python-mode-hook
                (lambda ()
                  (add-hook 'post-self-insert-hook
                            #'python-electric-pair-string-delimiter 'append t)))


      (use-package python
        :defer t
        :config
        (setq-default py-indent-tabs-mode nil)
        (setq-default flycheck-python-flake8-executable "flake8")
        (setq python-indent-offset 4)
        (setq python-indent-guess-indent-offset nil)
        (setq pytest-cmd-flags "-x -s --color=yes")
        (defun my-python-setup ()
          (interactive)
          (lsp)
          (electric-pair-mode)
          (anaconda-mode)
          (anaconda-eldoc-mode)
          (pyenv-mode)
          ;; (py-yapf-enable-on-save) ;; turns out this causes problems when you are
          ;; working collaboratively on code where everyone isn't yapf'ing their stuff.
          )
          (add-hook 'python-mode-hook 'my-python-setup))


    #+END_SRC
*** common-lisp
    #+BEGIN_SRC emacs-lisp
      (defun activate-slime-helper ()
        (when (file-exists-p "~/.quicklisp/slime-helper.el")
          (load (expand-file-name "~/.quicklisp/slime-helper.el"))
          (define-key slime-repl-mode-map (kbd "C-l")
            'slime-repl-clear-buffer))
        (remove-hook 'lisp-mode-hook #'activate-slime-helper))

      (add-hook 'lisp-mode-hook #'activate-slime-helper)

      (setq inferior-lisp-program "sbcl")

      (setq lisp-loop-forms-indentation   6
            lisp-simple-loop-indentation  2
            lisp-loop-keyword-indentation 6)

      (defun my/helpful-lisp-modes ()
        (interactive)
        (paredit-mode 1)
        (rainbow-delimiters-mode 2)
        (eldoc-mode 1))

      (add-hook 'lisp-mode-hook #'my/helpful-lisp-modes)
    #+END_SRC
*** emacs-lisp
    #+BEGIN_SRC emacs-lisp
      (defun my/turn-on-paredit-and-eldoc ()
        (interactive)
        (paredit-mode 1)
        (eldoc-mode))

      (add-hook 'emacs-lisp-mode-hook #'my/turn-on-paredit-and-eldoc)
      (add-hook 'ielm-mode-hook #'my/turn-on-paredit-and-eldoc)

      (use-package eldoc
        :config
        (progn
          (use-package diminish
            :init
            (progn (diminish 'eldoc-mode "")))
          (setq eldoc-idle-delay 0.3)
          (set-face-attribute 'eldoc-highlight-function-argument nil
                              :underline t :foreground "green"
                              :weight 'bold)))

      (defun ielm-other-window ()
        "Run ielm on other window"
        (interactive)
        (switch-to-buffer-other-window
         (get-buffer-create "*ielm*"))
        (call-interactively 'ielm))

      (define-key emacs-lisp-mode-map (kbd "C-c C-z") 'ielm-other-window)
      (define-key lisp-interaction-mode-map (kbd "C-c C-z") 'ielm-other-window)

      (bind-key "M-:" 'pp-eval-expression)

      (defun sanityinc/eval-last-sexp-or-region (prefix)
        "Eval region from BEG to END if active, otherwise the last sexp."
        (interactive "P")
        (if (and (mark) (use-region-p))
            (eval-region (min (point) (mark)) (max (point) (mark)))
          (pp-eval-last-sexp prefix)))

      (bind-key "C-x C-e" 'sanityinc/eval-last-sexp-or-region emacs-lisp-mode-map)

      (define-key lisp-mode-shared-map (kbd "RET") 'reindent-then-newline-and-indent)
    #+END_SRC
*** rust
    #+BEGIN_SRC emacs-lisp
      (use-package cargo
        :config
        (defun enable-cargo-visual-line ()
          (interactive)
          (visual-line-mode 1))
          ;; cargo-process-mode comes from cargo-minor mode.
          ;; this is the mode the buffer holding the output of cargo
          ;; commands takes.
        (add-hook 'cargo-process-mode-hook 'enable-cargo-visual-line))

      (use-package rust-mode
        :defer t
        :config
        (defun my-rust-setup ()
          (interactive)
          (lsp)
          (cargo-minor-mode)
          (hs-minor-mode)
          (rust-enable-format-on-save)
          (flycheck-mode)
          ;; (cargo-process--command-flags "--color never")
          (set-fill-column 100)
          (flycheck-rust-setup))
        (add-hook 'rust-mode-hook 'my-rust-setup))

      (setq lsp-rust-clippy-preference "on")
    #+END_SRC
*** TODO webprogramming
    #+BEGIN_SRC emacs-lisp

      ;;js2 setup is taken from https://blog.jft.rocks/javascript/emacs-and-typescript.html
      ;; NOTE not sure i want js2-mode anymore since jsx is supported by default
      ;;      and web mode tends to be good enough
      ;; (use-package js2-mode
      ;;   :ensure t
      ;;   :init
      ;;   (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode)))

      (use-package web-mode
        :defer t
        :mode ("\\.html\\'" "\\.css\\'" "\\.sass\\'" "\\.scss\\'" "\\.tera\\'" "\\.js[x]?\\'")
        :init
        (add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-mode))
        :config
        (defun my-web-mode-setup ()
          (interactive)
          (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
          (company-mode)
          (setq web-mode-enable-current-element-highlight t)
          (setq web-mode-enable-current-column-highlight t)
          (smartparens-mode 0)
          (setq web-mode-code-indent-offset 2)
          (electric-pair-mode)
          (rjsx-minor-mode)
          (set-fill-column 120)
          (linum-mode 1)
          (emmet-mode))
        (add-hook 'web-mode-hook 'my-web-mode-setup))

      ;; templating engines and what file extensions to associate them with
      ;; update as necessary
      (setq web-mode-engines-alist
            '(("django" . "\\.tera\\'")))
      ;; ("jinja" . "\\.djhtml\\'")))

      (add-hook 'web-mode-hook 'tera-web-mode-auto-pairs)
      (defun tera-web-mode-auto-pairs ()
        (when (string= (file-name-extension buffer-file-name) "tera")
          (setq web-mode-auto-pairs '(("{{ " . " }}")
                                      ("{% " . " %}")
                                      ("{%-" . " -%}")
                                      ("{# " . " #}")
                                      ("{#- " . " -#}")
                                      ("<!-" . "- | -->")))))
    #+END_SRC

    I believe this is for json formatting, which gets ran within JSON mode buffers...
    #+begin_src emacs-lisp
      (setq js-indent-level 2)
    #+end_src
**** typescript
     #+BEGIN_SRC emacs-lisp
       ;; Taken directly from the tide setup page. Don't know how good it is,
       ;; hopefully plays well enough just to get working with it.

       (defun setup-tide-mode ()
         (interactive)
         (tide-setup)
         (flycheck-mode +1)
         (setq flycheck-check-syntax-automatically '(save mode-enabled))
         (eldoc-mode +1)
         (tide-hl-identifier-mode +1)
         ;; company is an optional dependency. You have to
         ;; install it separately via package-install
         ;; `M-x package-install [ret] company`
         (company-mode +1))

       ;; aligns annotation to the right hand side
       (setq company-tooltip-align-annotations t)

       ;; formats the buffer before saving
       (add-hook 'before-save-hook 'tide-format-before-save)

       (add-hook 'typescript-mode-hook #'setup-tide-mode)

       (use-package tide
         :ensure t
         :after (typescript-mode company flycheck)
         :hook ((typescript-mode . tide-setup)
                (typescript-mode . tide-hl-identifier-mode)
                (before-save . tide-format-before-save)))

     #+END_SRC
**** vue(?)
     Disable ugly af vue background:
     #+BEGIN_SRC emacs-lisp
       (use-package vue-mode)
       (add-hook 'mmm-mode-hook
                 (lambda ()
                   (set-face-background 'mmm-default-submode-face nil)))
     #+END_SRC
*** elm
    setup is bare for now, just want to get going
    #+begin_src emacs-lisp
      (use-package elm-mode
        :config
        (defun elm-setup ()
          (interactive)
          (lsp)))
    #+end_src
*** TODO clojure
    #+BEGIN_SRC emacs-lisp
      ;; FROM BRAVECLOJURE

      ;;;;
      ;; Clojure
      ;;;;

      ;; Enable paredit for Clojure
      (add-hook 'clojure-mode-hook 'enable-paredit-mode)

      ;; This is useful for working with camel-case tokens, like names of
      ;; Java classes (e.g. JavaClassName)
      (add-hook 'clojure-mode-hook 'subword-mode)

      ;; A little more syntax highlighting
      (require 'clojure-mode-extra-font-locking)

      ;; syntax hilighting for midje
      (add-hook 'clojure-mode-hook
                (lambda ()
                  (setq inferior-lisp-program "lein repl")
                  (font-lock-add-keywords
                   nil
                   '(("(\\(facts?\\)"
                      (1 font-lock-keyword-face))
                     ("(\\(background?\\)"
                      (1 font-lock-keyword-face))))
                  (define-clojure-indent (fact 1))
                  (define-clojure-indent (facts 1))))

      ;;;;
      ;; Cider
      ;;;;

      ;; provides minibuffer documentation for the code you're typing into the repl
      (add-hook 'cider-mode-hook 'eldoc-mode)


      ;; go right to the REPL buffer when it's finished connecting
      (setq cider-repl-pop-to-buffer-on-connect t)

      ;; When there's a cider error, show its buffer and switch to it
      (setq cider-show-error-buffer t)
      (setq cider-auto-select-error-buffer t)

      ;; Where to store the cider history.
      (setq cider-repl-history-file "~/.emacs.d/cider-history")

      ;; Wrap when navigating history.
      (setq cider-repl-wrap-history t)

      ;; enable paredit in your REPL
      (add-hook 'cider-repl-mode-hook 'paredit-mode)

      ;; Use clojure mode for other extensions
      (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
      (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
      (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
      (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode))


      ;; key bindings
      ;; these help me out with the way I usually develop web apps
      (defun cider-start-http-server ()
        (interactive)
        (cider-load-current-buffer)
        (let ((ns (cider-current-ns)))
          (cider-repl-set-ns ns)
          (cider-interactive-eval (format "(println '(def server (%s/start))) (println 'server)" ns))
          (cider-interactive-eval (format "(def server (%s/start)) (println server)" ns))))


      (defun cider-refresh ()
        (interactive)
        (cider-interactive-eval (format "(user/reset)")))

      (defun cider-user-ns ()
        (interactive)
        (cider-repl-set-ns "user"))

      (eval-after-load 'cider
        '(progn
           (define-key clojure-mode-map (kbd "C-c C-v") 'cider-start-http-server)
           (define-key clojure-mode-map (kbd "C-M-r") 'cider-refresh)
           (define-key clojure-mode-map (kbd "C-c u") 'cider-user-ns)
           (define-key cider-mode-map (kbd "C-c u") 'cider-user-ns)))
    #+END_SRC
*** TODO latex-mode
    #+BEGIN_SRC emacs-lisp
      ;; (add-to-list 'auto-mode-alist '("\\.tex\\'" . latex-mode))
      ;; (add-to-list 'auto-mode-alist '("\\.tex\\'" . latex-mode))
      ;;(use-package auctex)
      (use-package tex
         :ensure auctex)
      ;; (use-package auctex)
      (defun generic-tex-minor-modes ()
        (interactive)
        ;; luatex works good for fancy utf8 stuff, i‚Äôve used it when xetex couldn‚Äôt
        ;; handle weird utf8 math symbols before, so keep that in mind.
        (setq TeX-engine 'xetex)
        (company-mode 1)
        (auto-fill-mode 1))

      (add-hook 'tex-mode-hook 'generic-tex-minor-modes)

    #+END_SRC
*** TODO c/c++
**** basic autocomplete
     Following Tuh-Do's tutorial/guide for C++ with emacs:
     #+BEGIN_SRC emacs-lisp
       (use-package company-c-headers)
       (add-to-list 'company-backends 'company-c-headers)
       (add-to-list 'company-c-headers-path-system "/usr/include/c++/8.2.1/")

     #+END_SRC
*** java
    #+BEGIN_SRC emacs-lisp
      (use-package lsp-java :ensure t :after lsp
        :config (add-hook 'java-mode-hook 'lsp))
    #+END_SRC
** bug fixes

   it's not good code if it doesn't have bugs in it.

   #+BEGIN_SRC emacs-lisp

     ;; fci mode has this unfortunate compatibility issue with the company-mode
     ;; completion menu, this is a workaround for it by the company-mode maintainer
     (defvar-local company-fci-mode-on-p nil)

     (defun company-turn-off-fci (&rest ignore)
       (when (boundp 'fci-mode)
         (setq company-fci-mode-on-p fci-mode)
         (when fci-mode (fci-mode -1))))

     (defun company-maybe-turn-on-fci (&rest ignore)
       (when company-fci-mode-on-p (fci-mode 1)))

     (add-hook 'company-completion-started-hook 'company-turn-off-fci)
     (add-hook 'company-completion-finished-hook 'company-maybe-turn-on-fci)
     (add-hook 'company-completion-cancelled-hook 'company-maybe-turn-on-fci)
   #+END_SRC



